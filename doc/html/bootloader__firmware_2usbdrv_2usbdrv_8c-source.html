<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>USB IR HID Device: bootloader_firmware/usbdrv/usbdrv.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>bootloader_firmware/usbdrv/usbdrv.c</h1><a href="bootloader__firmware_2usbdrv_2usbdrv_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Name: usbdrv.c</span>
<a name="l00002"></a>00002 <span class="comment"> * Project: AVR USB driver</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: Christian Starkjohann</span>
<a name="l00004"></a>00004 <span class="comment"> * Creation Date: 2004-12-29</span>
<a name="l00005"></a>00005 <span class="comment"> * Tabsize: 4</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH</span>
<a name="l00007"></a>00007 <span class="comment"> * License: Proprietary, free under certain conditions. See Documentation.</span>
<a name="l00008"></a>00008 <span class="comment"> * This Revision: $Id: usbdrv.c 155 2006-03-06 23:27:06Z cs $</span>
<a name="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="bootloader__firmware_2usbdrv_2iarcompat_8h.html">iarcompat.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#ifndef __IAR_SYSTEMS_ICC__</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;avr/io.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#   include &lt;avr/pgmspace.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#endif</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html">usbdrv.h</a>"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html">oddebug.h</a>"</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/*</span>
<a name="l00020"></a>00020 <span class="comment">General Description:</span>
<a name="l00021"></a>00021 <span class="comment">This module implements the C-part of the USB driver. See usbdrv.h for a</span>
<a name="l00022"></a>00022 <span class="comment">documentation of the entire driver.</span>
<a name="l00023"></a>00023 <span class="comment">*/</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef IAR_SECTION</span>
<a name="l00026"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#aa927c92dfe5b14f5b87f5ecabf4c14e">00026</a> <span class="preprocessor"></span><span class="preprocessor">#define IAR_SECTION(arg)</span>
<a name="l00027"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#55530f24354538975ee7102fb88f123a">00027</a> <span class="preprocessor"></span><span class="preprocessor">#define __no_init</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="comment">/* The macro IAR_SECTION is a hack to allow IAR-cc compatibility. On gcc, it</span>
<a name="l00030"></a>00030 <span class="comment"> * is defined to nothing. __no_init is required on IAR.</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">/* raw USB registers / interface to assembler code: */</span>
<a name="l00036"></a>00036 <span class="comment">/* usbRxBuf MUST be in 1 byte addressable range (because usbInputBuf is only 1 byte) */</span>
<a name="l00037"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#c05a996e552f0ab23ee75260e66a027d">00037</a> <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#55530f24354538975ee7102fb88f123a">__no_init</a> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="usbdrv_2usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>[2][<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>] <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#c05a996e552f0ab23ee75260e66a027d">__attribute__</a> ((section (<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#52a8394f6e172b45975aa2ffda16acca">USB_BUFFER_SECTION</a>))) <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#aa927c92dfe5b14f5b87f5ecabf4c14e">IAR_SECTION</a>(<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#52a8394f6e172b45975aa2ffda16acca">USB_BUFFER_SECTION</a>);<span class="comment">/* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */</span>
<a name="l00038"></a>00038 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a>;      <span class="comment">/* assigned during enumeration, defaults to 0 */</span>
<a name="l00039"></a>00039 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#b9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a>;   <span class="comment">/* device ID which should be set after status phase */</span>
<a name="l00040"></a>00040 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#a43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a>;   <span class="comment">/* currently selected configuration. Administered by driver, but not used */</span>
<a name="l00041"></a>00041 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       usbInputBuf;        <span class="comment">/* ptr to raw buffer used for receiving */</span>
<a name="l00042"></a>00042 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       usbAppBuf;          <span class="comment">/* ptr to raw buffer passed to app for processing */</span>
<a name="l00043"></a>00043 volatile <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">schar</a> <a class="code" href="usbdrv_2usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">usbRxLen</a>;        <span class="comment">/* = 0; number of bytes in usbAppBuf; 0 means free */</span>
<a name="l00044"></a>00044 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#e302a61abfeb0784f42a903dd44aad1e">usbCurrentTok</a>;      <span class="comment">/* last token received */</span>
<a name="l00045"></a>00045 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#e2a9422baba7da8914129e0784ab2c05">usbRxToken</a>;         <span class="comment">/* token for data we received */</span>
<a name="l00046"></a>00046 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;   <span class="comment">/* remaining number of bytes, no msg to send if -1 (see usbMsgPtr) */</span>
<a name="l00047"></a>00047 volatile <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">schar</a> <a class="code" href="usbdrv_2usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = -1;   <span class="comment">/* number of bytes to transmit with next IN token */</span>
<a name="l00048"></a>00048 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];<span class="comment">/* data to transmit with next IN, free if usbTxLen == -1 */</span>
<a name="l00049"></a>00049 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="comment">/* uchar       usbRxEndp;          endpoint which was addressed (1 bit in MSB) [not impl] */</span>
<a name="l00051"></a>00051 <span class="keyword">volatile</span> <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">schar</a> <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#2e90de9a02954cab2f72d0f509bc4714">usbTxLen1</a> = -1;  <span class="comment">/* TX count for endpoint 1 */</span>
<a name="l00052"></a>00052 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_2usbdrv_8c.html#92ad467856cc7e0efeafcda41671ea75">usbTxBuf1</a>[USB_BUFSIZE];<span class="comment">/* TX data for endpoint 1 */</span>
<a name="l00053"></a>00053 <span class="preprocessor">#endif</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       usbAckBuf[1] = {<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#7f9994b8bc3a4864604aa8041ed90faf">USBPID_ACK</a>};    <span class="comment">/* transmit buffer for ack tokens */</span>
<a name="l00055"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#f51ba5254931f6a71985e275305242d7">00055</a> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#f51ba5254931f6a71985e275305242d7">usbNakBuf</a>[1] = {<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>};    <span class="comment">/* transmit buffer for nak tokens */</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">/* USB status registers / not shared with asm code */</span>
<a name="l00058"></a><a class="code" href="usbdrv_2usbdrv_8h.html#5f78c8584830588b8c0c8f2a27772f8e">00058</a> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>           *<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a>;     <span class="comment">/* data to transmit next -- ROM or RAM address */</span>
<a name="l00059"></a>00059 <span class="keyword">static</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    usbMsgFlags;    <span class="comment">/* flag values see below */</span>
<a name="l00060"></a>00060 <span class="keyword">static</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    usbIsReset;     <span class="comment">/* = 0; USB bus is in reset phase */</span>
<a name="l00061"></a>00061 
<a name="l00062"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#2a36a35f900ede87e7c897bc778065c8">00062</a> <span class="preprocessor">#define USB_FLG_TX_PACKET       (1&lt;&lt;0)</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="comment">/* Leave free 6 bits after TX_PACKET. This way we can increment usbMsgFlags to toggle TX_PACKET */</span>
<a name="l00064"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#06db19dbad17d54fc6f3742ab0afba69">00064</a> <span class="preprocessor">#define USB_FLG_MSGPTR_IS_ROM   (1&lt;&lt;6)</span>
<a name="l00065"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#5e3bb8fb87bbde80118c36559bf41bcb">00065</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_FLG_USE_DEFAULT_RW  (1&lt;&lt;7)</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 <span class="comment">/*</span>
<a name="l00068"></a>00068 <span class="comment">optimizing hints:</span>
<a name="l00069"></a>00069 <span class="comment">- do not post/pre inc/dec integer values in operations</span>
<a name="l00070"></a>00070 <span class="comment">- assign value of PRG_RDB() to register variables and don't use side effects in arg</span>
<a name="l00071"></a>00071 <span class="comment">- use narrow scope for variables which should be in X/Y/Z register</span>
<a name="l00072"></a>00072 <span class="comment">- assign char sized expressions to variables to force 8 bit arithmetics</span>
<a name="l00073"></a>00073 <span class="comment">*/</span>
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keyword">static</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">char</span> usbDescrDevice[] = {    <span class="comment">/* USB device descriptor */</span>
<a name="l00078"></a>00078     18,         <span class="comment">/* sizeof(usbDescrDevice): length of descriptor in bytes */</span>
<a name="l00079"></a>00079     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#5b76593f7b6295a4a599aba4476ec258">USBDESCR_DEVICE</a>,    <span class="comment">/* descriptor type */</span>
<a name="l00080"></a>00080     0x01, 0x01, <span class="comment">/* USB version supported */</span>
<a name="l00081"></a>00081     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#9ce4f96ad98b3db8205691e8bc723e55">USB_CFG_DEVICE_CLASS</a>,
<a name="l00082"></a>00082     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#89e5ad66f8b835866e7d836c73bfd30d">USB_CFG_DEVICE_SUBCLASS</a>,
<a name="l00083"></a>00083     0,          <span class="comment">/* protocol */</span>
<a name="l00084"></a>00084     8,          <span class="comment">/* max packet size */</span>
<a name="l00085"></a>00085     <a class="code" href="usbconfig_8h.html#9326b8ec9f809ce66d54349691646930">USB_CFG_VENDOR_ID</a>,  <span class="comment">/* 2 bytes */</span>
<a name="l00086"></a>00086     <a class="code" href="usbconfig_8h.html#bc740455309399430b0f49bf7931d1d7">USB_CFG_DEVICE_ID</a>,  <span class="comment">/* 2 bytes */</span>
<a name="l00087"></a>00087     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#ba3c7c0cd4055ba3bbf5df38e57b6d27">USB_CFG_DEVICE_VERSION</a>, <span class="comment">/* 2 bytes */</span>
<a name="l00088"></a>00088 <span class="preprocessor">#if USB_CFG_VENDOR_NAME_LEN</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>    1,          <span class="comment">/* manufacturer string index */</span>
<a name="l00090"></a>00090 <span class="preprocessor">#else</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>    0,          <span class="comment">/* manufacturer string index */</span>
<a name="l00092"></a>00092 <span class="preprocessor">#endif</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_DEVICE_NAME_LEN</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>    2,          <span class="comment">/* product string index */</span>
<a name="l00095"></a>00095 <span class="preprocessor">#else</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>    0,          <span class="comment">/* product string index */</span>
<a name="l00097"></a>00097 <span class="preprocessor">#endif</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_SERIAL_NUMBER_LENGTH</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>    3,          <span class="comment">/* serial number string index */</span>
<a name="l00100"></a>00100 <span class="preprocessor">#else</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>    0,          <span class="comment">/* serial number string index */</span>
<a name="l00102"></a>00102 <span class="preprocessor">#endif</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>    1,          <span class="comment">/* number of configurations */</span>
<a name="l00104"></a>00104 };
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">static</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">char</span> usbDescrConfig[] = {    <span class="comment">/* USB configuration descriptor */</span>
<a name="l00107"></a>00107     9,          <span class="comment">/* sizeof(usbDescrConfig): length of descriptor in bytes */</span>
<a name="l00108"></a>00108     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#6ff1081ad7212a0c7009ef5b79f3669f">USBDESCR_CONFIG</a>,    <span class="comment">/* descriptor type */</span>
<a name="l00109"></a>00109     (18 + 7 * <a class="code" href="bootloader__firmware_2usbconfig_8h.html#fe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a>
<a name="l00110"></a>00110 <span class="preprocessor">#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>     + 9
<a name="l00112"></a>00112 <span class="preprocessor">#endif</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span>        ), 0,   <span class="comment">/* total length of data returned (including inlined descriptors) */</span>
<a name="l00114"></a>00114     1,          <span class="comment">/* number of interfaces in this configuration */</span>
<a name="l00115"></a>00115     1,          <span class="comment">/* index of this configuration */</span>
<a name="l00116"></a>00116     0,          <span class="comment">/* configuration name string index */</span>
<a name="l00117"></a>00117 #<span class="keywordflow">if</span> <a class="code" href="bootloader__firmware_2usbconfig_8h.html#d5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a>
<a name="l00118"></a>00118     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#fa0dd9c06af4b033461ba3c755ca90bb">USBATTR_SELFPOWER</a>,  <span class="comment">/* attributes */</span>
<a name="l00119"></a>00119 #<span class="keywordflow">else</span>
<a name="l00120"></a>00120     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#9731bc516bc018f3b0f50a455d5a5681">USBATTR_BUSPOWER</a>,   <span class="comment">/* attributes */</span>
<a name="l00121"></a>00121 #endif
<a name="l00122"></a>00122     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#be324d9b00dc186bcbac65ed0f94811c">USB_CFG_MAX_BUS_POWER</a>/2,            <span class="comment">/* max USB current in 2mA units */</span>
<a name="l00123"></a>00123 <span class="comment">/* interface descriptor follows inline: */</span>
<a name="l00124"></a>00124     9,          <span class="comment">/* sizeof(usbDescrInterface): length of descriptor in bytes */</span>
<a name="l00125"></a>00125     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1ce81e6fb124d8747018b4343faa65ba">USBDESCR_INTERFACE</a>, <span class="comment">/* descriptor type */</span>
<a name="l00126"></a>00126     0,          <span class="comment">/* index of this interface */</span>
<a name="l00127"></a>00127     0,          <span class="comment">/* alternate setting for this interface */</span>
<a name="l00128"></a>00128     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#fe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a>,   <span class="comment">/* endpoints excl 0: number of endpoint descriptors to follow */</span>
<a name="l00129"></a>00129     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#34f6fe9486b66e8220a82a0eb87a7447">USB_CFG_INTERFACE_CLASS</a>,
<a name="l00130"></a>00130     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#c643f27afa43062c19b8f0674b6be1b5">USB_CFG_INTERFACE_SUBCLASS</a>,
<a name="l00131"></a>00131     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#8ddab89b764bfd88d024c7d9c9931de3">USB_CFG_INTERFACE_PROTOCOL</a>,
<a name="l00132"></a>00132     0,          <span class="comment">/* string index for interface */</span>
<a name="l00133"></a>00133 #<span class="keywordflow">if</span> <a class="code" href="bootloader__firmware_2usbconfig_8h.html#47d9bef5c10a1b9ba917eca583d2abc9">USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH</a>    <span class="comment">/* HID descriptor */</span>
<a name="l00134"></a>00134     9,          <span class="comment">/* sizeof(usbDescrHID): length of descriptor in bytes */</span>
<a name="l00135"></a>00135     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#de4fe1fba6aca94a379fdbacbbcc6800">USBDESCR_HID</a>,   <span class="comment">/* descriptor type: HID */</span>
<a name="l00136"></a>00136     0x01, 0x01, <span class="comment">/* BCD representation of HID version */</span>
<a name="l00137"></a>00137     0x00,       <span class="comment">/* target country code */</span>
<a name="l00138"></a>00138     0x01,       <span class="comment">/* number of HID Report (or other HID class) Descriptor infos to follow */</span>
<a name="l00139"></a>00139     0x22,       <span class="comment">/* descriptor type: report */</span>
<a name="l00140"></a>00140     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  <span class="comment">/* total length of report descriptor */</span>
<a name="l00141"></a>00141 #endif
<a name="l00142"></a>00142 #<span class="keywordflow">if</span> <a class="code" href="bootloader__firmware_2usbconfig_8h.html#fe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a>    <span class="comment">/* endpoint descriptor for endpoint 1 */</span>
<a name="l00143"></a>00143     7,          <span class="comment">/* sizeof(usbDescrEndpoint) */</span>
<a name="l00144"></a>00144     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#b2c475dbe374ed8bc514893fb97a6083">USBDESCR_ENDPOINT</a>,  <span class="comment">/* descriptor type = endpoint */</span>
<a name="l00145"></a>00145     0x81,       <span class="comment">/* IN endpoint number 1 */</span>
<a name="l00146"></a>00146     0x03,       <span class="comment">/* attrib: Interrupt endpoint */</span>
<a name="l00147"></a>00147     8, 0,       <span class="comment">/* maximum packet size */</span>
<a name="l00148"></a>00148     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#9cccddfefa62f926a0d7bba9f183a4d3">USB_CFG_INTR_POLL_INTERVAL</a>, <span class="comment">/* in ms */</span>
<a name="l00149"></a>00149 #endif
<a name="l00150"></a>00150 };
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="keyword">static</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">char</span> usbDescrString0[] = {   <span class="comment">/* language descriptor */</span>
<a name="l00153"></a>00153     4,          <span class="comment">/* sizeof(usbDescrString0): length of descriptor in bytes */</span>
<a name="l00154"></a>00154     3,          <span class="comment">/* descriptor type */</span>
<a name="l00155"></a>00155     0x09, 0x04, <span class="comment">/* language index (0x0409 = US-English) */</span>
<a name="l00156"></a>00156 };
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="preprocessor">#if USB_CFG_VENDOR_NAME_LEN</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">int</span>  usbDescrString1[] = {
<a name="l00160"></a>00160     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#d94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(<a class="code" href="bootloader__firmware_2usbconfig_8h.html#3085d820d9dc6e939737a3f1b9a457d7">USB_CFG_VENDOR_NAME_LEN</a>),
<a name="l00161"></a>00161     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#25a2baf5c8feb0982a47050423add0ec">USB_CFG_VENDOR_NAME</a>
<a name="l00162"></a>00162 };
<a name="l00163"></a>00163 <span class="preprocessor">#endif</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_DEVICE_NAME_LEN</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">int</span>  usbDescrString2[] = {
<a name="l00166"></a>00166     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#d94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(<a class="code" href="bootloader__firmware_2usbconfig_8h.html#e68f17e6baf13805abc56e74beadeb57">USB_CFG_DEVICE_NAME_LEN</a>),
<a name="l00167"></a>00167     <a class="code" href="bootloader__firmware_2usbconfig_8h.html#9b482a2b2740652ffe7dcb6695ca0c91">USB_CFG_DEVICE_NAME</a>
<a name="l00168"></a>00168 };
<a name="l00169"></a>00169 <span class="preprocessor">#endif</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>
<a name="l00171"></a>00171 <span class="comment">/* We don't use prog_int or prog_int16_t for compatibility with various libc</span>
<a name="l00172"></a>00172 <span class="comment"> * versions. Here's an other compatibility hack:</span>
<a name="l00173"></a>00173 <span class="comment"> */</span>
<a name="l00174"></a>00174 <span class="preprocessor">#ifndef PRG_RDB</span>
<a name="l00175"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#f7c7b7892c3be6693e9107a0b4e1a75e">00175</a> <span class="preprocessor"></span><span class="preprocessor">#define PRG_RDB(addr)   pgm_read_byte(addr)</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>
<a name="l00178"></a><a class="code" href="unionconverter__t.html">00178</a> <span class="keyword">typedef</span> <span class="keyword">union</span>{
<a name="l00179"></a><a class="code" href="unionconverter__t.html#a838a8d4780d6cd64701379b48591efd">00179</a>     <span class="keywordtype">unsigned</span>    word;
<a name="l00180"></a><a class="code" href="unionconverter__t.html#6303c2a2b30bdd9ad5dacb62ef19682c">00180</a>     <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       *ptr;
<a name="l00181"></a><a class="code" href="unionconverter__t.html#f1aa09c318011859f8ff23c5ccd18996">00181</a>     <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       bytes[2];
<a name="l00182"></a>00182 }<a class="code" href="unionconverter__t.html">converter_t</a>;
<a name="l00183"></a>00183 <span class="comment">/* We use this union to do type conversions. This is better optimized than</span>
<a name="l00184"></a>00184 <span class="comment"> * type casts in gcc 3.4.3 and much better than using bit shifts to build</span>
<a name="l00185"></a>00185 <span class="comment"> * ints from chars. Byte ordering is not a problem on an 8 bit platform.</span>
<a name="l00186"></a>00186 <span class="comment"> */</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    usbTxPacketCnt1;
<a name="l00192"></a>00192 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    usbHalted1;         <span class="comment">/* not 0 if endpoint 1 is halted */</span>
<a name="l00194"></a>00194 <span class="preprocessor">#endif</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>
<a name="l00196"></a><a class="code" href="usbdrv_2usbdrv_8h.html#afa474a799eed02d362bfdfb8a36602c">00196</a> <span class="keywordtype">void</span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#d3eef923d7e69592f8b3aa3bf983bb92">usbSetInterrupt</a>(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00197"></a>00197 {
<a name="l00198"></a>00198 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       *p, i;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(usbHalted1)
<a name="l00202"></a>00202         <span class="keywordflow">return</span>;
<a name="l00203"></a>00203 <span class="preprocessor">#endif</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(len &gt; 8) <span class="comment">/* interrupt transfers are limited to 8 bytes */</span>
<a name="l00205"></a>00205         len = 8;
<a name="l00206"></a>00206     i = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>;
<a name="l00207"></a>00207     <span class="keywordflow">if</span>(usbTxPacketCnt1 &amp; 1)
<a name="l00208"></a>00208         i = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ddf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a>;
<a name="l00209"></a>00209     <span class="keywordflow">if</span>(usbTxLen1 &lt; 0){      <span class="comment">/* packet buffer was empty */</span>
<a name="l00210"></a>00210         usbTxPacketCnt1++;
<a name="l00211"></a>00211     }<span class="keywordflow">else</span>{
<a name="l00212"></a>00212         usbTxLen1 = -1;     <span class="comment">/* avoid sending incomplete interrupt data */</span>
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214     p = usbTxBuf1;
<a name="l00215"></a>00215     *p++ = i;
<a name="l00216"></a>00216     <span class="keywordflow">for</span>(i=len;i--;)
<a name="l00217"></a>00217         *p++ = *data++;
<a name="l00218"></a>00218     <a class="code" href="usbdrv_2usbdrv_8h.html#96a513e4c0943ba6bd42aa1289874340">usbCrc16Append</a>(&amp;usbTxBuf1[1], len);
<a name="l00219"></a>00219     usbTxLen1 = len + 4;    <span class="comment">/* len must be given including sync byte */</span>
<a name="l00220"></a>00220 <span class="preprocessor">#if DEBUG_LEVEL &gt; 1</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x21, usbTxBuf1, usbTxLen1-1);
<a name="l00222"></a>00222 <span class="preprocessor">#else</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#1b3ae5f24b3863d451c3648fa2ff57be">DBG1</a>(0x21, usbTxBuf1 + 1, 2);
<a name="l00224"></a>00224 <span class="preprocessor">#endif</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>}
<a name="l00226"></a>00226 <span class="preprocessor">#endif</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="keyword">static</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    usbRead(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#5e3bb8fb87bbde80118c36559bf41bcb">USB_FLG_USE_DEFAULT_RW</a>){
<a name="l00233"></a>00233 <span class="preprocessor">#endif</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>        <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> i = len, *r = usbMsgPtr;
<a name="l00235"></a>00235         <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#06db19dbad17d54fc6f3742ab0afba69">USB_FLG_MSGPTR_IS_ROM</a>){    <span class="comment">/* ROM data */</span>
<a name="l00236"></a>00236             <span class="keywordflow">while</span>(i--){
<a name="l00237"></a>00237                 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> c = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#f7c7b7892c3be6693e9107a0b4e1a75e">PRG_RDB</a>(r);    <span class="comment">/* assign to char size variable to enforce byte ops */</span>
<a name="l00238"></a>00238                 *data++ = c;
<a name="l00239"></a>00239                 r++;
<a name="l00240"></a>00240             }
<a name="l00241"></a>00241         }<span class="keywordflow">else</span>{                  <span class="comment">/* RAM data */</span>
<a name="l00242"></a>00242             <span class="keywordflow">while</span>(i--)
<a name="l00243"></a>00243                 *data++ = *r++;
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245         usbMsgPtr = r;
<a name="l00246"></a>00246         <span class="keywordflow">return</span> len;
<a name="l00247"></a>00247 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>    }<span class="keywordflow">else</span>{
<a name="l00249"></a>00249         <span class="keywordflow">if</span>(len != 0)    <span class="comment">/* don't bother app with 0 sized reads */</span>
<a name="l00250"></a>00250             <span class="keywordflow">return</span> usbFunctionRead(data, len);
<a name="l00251"></a>00251         <span class="keywordflow">return</span> 0;
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253 <span class="preprocessor">#endif</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>}
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="comment">/* Don't make this function static to avoid inlining.</span>
<a name="l00257"></a>00257 <span class="comment"> * The entire function would become too large and exceed the range of</span>
<a name="l00258"></a>00258 <span class="comment"> * relative jumps.</span>
<a name="l00259"></a>00259 <span class="comment"> * 2006-02-25: Either gcc 3.4.3 is better than the gcc used when the comment</span>
<a name="l00260"></a>00260 <span class="comment"> * above was written, or other parts of the code have changed. We now get</span>
<a name="l00261"></a>00261 <span class="comment"> * better results with an inlined function. Test condition: PowerSwitch code.</span>
<a name="l00262"></a>00262 <span class="comment"> */</span>
<a name="l00263"></a>00263 <span class="keyword">static</span> <span class="keywordtype">void</span> usbProcessRx(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00264"></a>00264 {
<a name="l00265"></a>00265 <a class="code" href="structusbRequest.html">usbRequest_t</a>    *rq = (<span class="keywordtype">void</span> *)data;
<a name="l00266"></a>00266 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>           replyLen = 0, flags = USB_FLG_USE_DEFAULT_RW;
<a name="l00267"></a>00267 <span class="comment">/* We use if() cascades because the compare is done byte-wise while switch()</span>
<a name="l00268"></a>00268 <span class="comment"> * is int-based. The if() cascades are therefore more efficient.</span>
<a name="l00269"></a>00269 <span class="comment"> */</span>
<a name="l00270"></a>00270 <span class="preprocessor">#if DEBUG_LEVEL &gt; 1</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x10 + (usbRxToken == (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3e2083acfa1300227dce323ca04db880">USBPID_SETUP</a>), data, len);
<a name="l00272"></a>00272 <span class="preprocessor">#else</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#1b3ae5f24b3863d451c3648fa2ff57be">DBG1</a>(0x10 + (usbRxToken == (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3e2083acfa1300227dce323ca04db880">USBPID_SETUP</a>), data, 2);
<a name="l00274"></a>00274 <span class="preprocessor">#endif</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(usbRxToken == (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3e2083acfa1300227dce323ca04db880">USBPID_SETUP</a>){
<a name="l00276"></a>00276         <span class="keywordflow">if</span>(len == 8){   <span class="comment">/* Setup size must be always 8 bytes. Ignore otherwise. */</span>
<a name="l00277"></a>00277             <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> type = rq-&gt;<a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ef7b9c4cc4266e79c677fd42e2abb40e">USBRQ_TYPE_MASK</a>;
<a name="l00278"></a>00278             <span class="keywordflow">if</span>(type == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#a2eaf9447ddfc30442e8b6bd13cfd969">USBRQ_TYPE_STANDARD</a>){
<a name="l00279"></a>00279                 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *replyData = <a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 9; <span class="comment">/* there is 3 bytes free space at the end of the buffer */</span>
<a name="l00280"></a>00280                 replyData[0] = 0;   <span class="comment">/* common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */</span>
<a name="l00281"></a>00281                 <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#523252bd739d1b14018ec34e49466d72">USBRQ_GET_STATUS</a>){           <span class="comment">/* 0 */</span>
<a name="l00282"></a>00282                     <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#c05a996e552f0ab23ee75260e66a027d">__attribute__</a>((__unused__)) recipient = rq-&gt;bmRequestType &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#5ae0c6cdfa26c87300c3a01aa2b0c7e2">USBRQ_RCPT_MASK</a>;  <span class="comment">/* assign arith ops to variables to enforce byte size */</span>
<a name="l00283"></a>00283 <span class="preprocessor">#if USB_CFG_IS_SELF_POWERED</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span>                    <span class="keywordflow">if</span>(recipient == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#eb145a6378e20ee3aedaa81fffd08d5d">USBRQ_RCPT_DEVICE</a>)
<a name="l00285"></a>00285                         replyData[0] =  <a class="code" href="bootloader__firmware_2usbconfig_8h.html#d5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a>;
<a name="l00286"></a>00286 <span class="preprocessor">#endif</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT &amp;&amp; USB_CFG_IMPLEMENT_HALT</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>                    <span class="keywordflow">if</span>(usbHalted1 &amp;&amp; recipient == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#6c25d62097af881d30af436c07773a26">USBRQ_RCPT_ENDPOINT</a> &amp;&amp; rq-&gt;<a class="code" href="structusbRequest.html#efa059246bf079d5b42af148a2ad6a95">wIndex</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 0x81)   <span class="comment">/* request status for endpoint 1 */</span>
<a name="l00289"></a>00289                         replyData[0] = 1;
<a name="l00290"></a>00290 <span class="preprocessor">#endif</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>                    replyData[1] = 0;
<a name="l00292"></a>00292                     replyLen = 2;
<a name="l00293"></a>00293                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#6837bf1e17c56a25b97db0be68b03519">USBRQ_SET_ADDRESS</a>){    <span class="comment">/* 5 */</span>
<a name="l00294"></a>00294                     usbNewDeviceAddr = rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0];
<a name="l00295"></a>00295                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#225b041572762941a96694d5498e853e">USBRQ_GET_DESCRIPTOR</a>){ <span class="comment">/* 6 */</span>
<a name="l00296"></a>00296                     flags = USB_FLG_MSGPTR_IS_ROM | USB_FLG_USE_DEFAULT_RW;
<a name="l00297"></a>00297                     <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[1] == 1){   <span class="comment">/* descriptor type requested */</span>
<a name="l00298"></a>00298                         replyLen = <span class="keyword">sizeof</span>(usbDescrDevice);
<a name="l00299"></a>00299                         replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbDescrDevice;
<a name="l00300"></a>00300                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[1] == 2){
<a name="l00301"></a>00301                         replyLen = <span class="keyword">sizeof</span>(usbDescrConfig);
<a name="l00302"></a>00302                         replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbDescrConfig;
<a name="l00303"></a>00303                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[1] == 3){ <span class="comment">/* string descriptor */</span>
<a name="l00304"></a>00304                         <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 0){   <span class="comment">/* descriptor index */</span>
<a name="l00305"></a>00305                             replyLen = <span class="keyword">sizeof</span>(usbDescrString0);
<a name="l00306"></a>00306                             replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbDescrString0;
<a name="l00307"></a>00307 <span class="preprocessor">#if USB_CFG_VENDOR_NAME_LEN</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span>                        }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 1){
<a name="l00309"></a>00309                             replyLen = <span class="keyword">sizeof</span>(usbDescrString1);
<a name="l00310"></a>00310                             replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbDescrString1;
<a name="l00311"></a>00311 <span class="preprocessor">#endif</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_DEVICE_NAME_LEN</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>                        }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 2){
<a name="l00314"></a>00314                             replyLen = <span class="keyword">sizeof</span>(usbDescrString2);
<a name="l00315"></a>00315                             replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbDescrString2;
<a name="l00316"></a>00316 <span class="preprocessor">#endif</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_SERIAL_NUMBER_LENGTH</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>                        }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 3){
<a name="l00319"></a>00319                             replyLen = 2 * <a class="code" href="bootloader__firmware_2usbconfig_8h.html#4e22a06a33b9e7aafebac88906ba3aa1">USB_CFG_SERIAL_NUMBER_LENGTH</a> + 2;
<a name="l00320"></a>00320                             replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbCfgSerialNumberStringDescriptor;
<a name="l00321"></a>00321 <span class="preprocessor">#endif</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>                        }
<a name="l00323"></a>00323                     }
<a name="l00324"></a>00324 <span class="preprocessor">#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span>                    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[1] == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#de4fe1fba6aca94a379fdbacbbcc6800">USBDESCR_HID</a>){           <span class="comment">/* 0x21 */</span>
<a name="l00326"></a>00326                         replyLen = 9;
<a name="l00327"></a>00327                         replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)usbDescrConfig + 18;
<a name="l00328"></a>00328                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[1] == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2ef6d7e2fe214a3d3a14f5419550bb0">USBDESCR_HID_REPORT</a>){   <span class="comment">/* 0x22 */</span>
<a name="l00329"></a>00329                         replyLen = USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH;
<a name="l00330"></a>00330                         replyData = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)<a class="code" href="usbdrv_2usbdrv_8h.html#37718d9af25fd62f30b25e057468e39b">usbHidReportDescriptor</a>;
<a name="l00331"></a>00331                     }
<a name="l00332"></a>00332 <span class="preprocessor">#endif</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#16d2228bcfa8944c18a39df43016cea5">USBRQ_GET_CONFIGURATION</a>){  <span class="comment">/* 8 */</span>
<a name="l00334"></a>00334                     replyLen = 1;
<a name="l00335"></a>00335                     replyData = &amp;usbConfiguration;  <span class="comment">/* send current configuration value */</span>
<a name="l00336"></a>00336                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#fc6adbbfd47da950ccf50277a41bfe58">USBRQ_SET_CONFIGURATION</a>){  <span class="comment">/* 9 */</span>
<a name="l00337"></a>00337                     usbConfiguration = rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0];
<a name="l00338"></a>00338 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span>                    usbHalted1 = 0;
<a name="l00340"></a>00340 <span class="preprocessor">#endif</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#44a94b5f45d9ffb957b9590eea8a73a4">USBRQ_GET_INTERFACE</a>){      <span class="comment">/* 10 */</span>
<a name="l00342"></a>00342                     replyLen = 1;
<a name="l00343"></a>00343 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#82766d6fb4294e1cb5f7cb2086e81715">USBRQ_CLEAR_FEATURE</a> || rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1802461b0f91708022a66f407fadd1f1">USBRQ_SET_FEATURE</a>){   <span class="comment">/* 1|3 */</span>
<a name="l00346"></a>00346                     <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 0 &amp;&amp; rq-&gt;<a class="code" href="structusbRequest.html#efa059246bf079d5b42af148a2ad6a95">wIndex</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0] == 0x81){   <span class="comment">/* feature 0 == HALT for endpoint == 1 */</span>
<a name="l00347"></a>00347                         usbHalted1 = rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> - 1;
<a name="l00348"></a>00348                         <span class="keywordflow">if</span>(usbHalted1){
<a name="l00349"></a>00349                             usbTxBuf1[0] = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00350"></a>00350                             usbTxLen1 = 2;      <span class="comment">/* length including sync byte */</span>
<a name="l00351"></a>00351                         }
<a name="l00352"></a>00352                         usbTxPacketCnt1 = 0;    <span class="comment">/* reset data toggling for interrupt endpoint */</span>
<a name="l00353"></a>00353                     }
<a name="l00354"></a>00354 <span class="preprocessor">#endif</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#904cc1bbdd859501d590ce47099a49ec">USBRQ_SET_INTERFACE</a>){      <span class="comment">/* 11 */</span>
<a name="l00356"></a>00356                     usbTxPacketCnt1 = 0;        <span class="comment">/* reset data toggling for interrupt endpoint */</span>
<a name="l00357"></a>00357 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span>                    usbHalted1 = 0;
<a name="l00359"></a>00359 <span class="preprocessor">#endif</span>
<a name="l00360"></a>00360 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>                }<span class="keywordflow">else</span>{
<a name="l00362"></a>00362                     <span class="comment">/* the following requests can be ignored, send default reply */</span>
<a name="l00363"></a>00363                     <span class="comment">/* 1: CLEAR_FEATURE, 3: SET_FEATURE, 7: SET_DESCRIPTOR */</span>
<a name="l00364"></a>00364                     <span class="comment">/* 12: SYNCH_FRAME */</span>
<a name="l00365"></a>00365                 }
<a name="l00366"></a>00366                 usbMsgPtr = replyData;
<a name="l00367"></a>00367                 <span class="keywordflow">if</span>(!rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[1] &amp;&amp; replyLen &gt; rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0])  <span class="comment">/* max length is in */</span>
<a name="l00368"></a>00368                     replyLen = rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0];
<a name="l00369"></a>00369             }<span class="keywordflow">else</span>{  <span class="comment">/* not a standard request -- must be vendor or class request */</span>
<a name="l00370"></a>00370                 replyLen = <a class="code" href="bootloader__firmware_2main_8c.html#e6f351eca7bf6fb1251f9a478cbae2b0">usbFunctionSetup</a>(data);
<a name="l00371"></a>00371 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>                <span class="keywordflow">if</span>(replyLen == 0xff){   <span class="comment">/* use user-supplied read/write function */</span>
<a name="l00373"></a>00373                     <span class="keywordflow">if</span>((rq-&gt;<a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#7754f61bfa2e16800aa396896092f50a">USBRQ_DIR_MASK</a>) == <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#04a0c4970f7371115638586bc8a14325">USBRQ_DIR_DEVICE_TO_HOST</a>){
<a name="l00374"></a>00374                         replyLen = rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[0];    <span class="comment">/* IN transfers only */</span>
<a name="l00375"></a>00375                     }
<a name="l00376"></a>00376                     flags = 0;  <span class="comment">/* we have no valid msg, use user supplied read/write functions */</span>
<a name="l00377"></a>00377                 }
<a name="l00378"></a>00378 <span class="preprocessor">#endif</span>
<a name="l00379"></a>00379 <span class="preprocessor"></span>            }
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381         <span class="comment">/* make sure that data packets which are sent as ACK to an OUT transfer are always zero sized */</span>
<a name="l00382"></a>00382     }<span class="keywordflow">else</span>{  <span class="comment">/* DATA packet from out request */</span>
<a name="l00383"></a>00383 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00384"></a>00384 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!(usbMsgFlags &amp; USB_FLG_USE_DEFAULT_RW)){
<a name="l00385"></a>00385             <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> rval = <a class="code" href="bootloader__firmware_2main_8c.html#92f69288e90801df366cde5a838a818f">usbFunctionWrite</a>(data, len);
<a name="l00386"></a>00386             replyLen = 0xff;
<a name="l00387"></a>00387             <span class="keywordflow">if</span>(rval == 0xff){       <span class="comment">/* an error occurred */</span>
<a name="l00388"></a>00388                 <span class="comment">/* usbMsgLen = 0xff; cancel potentially pending ACK [has been done by ASM module when OUT token arrived] */</span>
<a name="l00389"></a>00389                 <a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[0] = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00390"></a>00390                 usbTxLen = 2;       <span class="comment">/* length including sync byte */</span>
<a name="l00391"></a>00391             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rval != 0){    <span class="comment">/* This was the final package */</span>
<a name="l00392"></a>00392                 replyLen = 0;       <span class="comment">/* answer with a zero-sized data packet */</span>
<a name="l00393"></a>00393             }
<a name="l00394"></a>00394             flags = 0;    <span class="comment">/* start with a DATA1 package, stay with user supplied write() function */</span>
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396 <span class="preprocessor">#else</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span>        replyLen = 0;      <span class="comment">/* send zero-sized block as ACK */</span>
<a name="l00398"></a>00398 <span class="preprocessor">#endif</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>    }
<a name="l00400"></a>00400     usbMsgFlags = flags;
<a name="l00401"></a>00401     <a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = replyLen;
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="keyword">static</span> <span class="keywordtype">void</span> usbBuildTxBlock(<span class="keywordtype">void</span>)
<a name="l00407"></a>00407 {
<a name="l00408"></a>00408 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       wantLen, len, txLen, token;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     wantLen = <a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a>;
<a name="l00411"></a>00411     <span class="keywordflow">if</span>(wantLen &gt; 8)
<a name="l00412"></a>00412         wantLen = 8;
<a name="l00413"></a>00413     <a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> -= wantLen;
<a name="l00414"></a>00414     token = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>;
<a name="l00415"></a>00415     <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#2a36a35f900ede87e7c897bc778065c8">USB_FLG_TX_PACKET</a>)
<a name="l00416"></a>00416         token = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ddf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a>;
<a name="l00417"></a>00417     usbMsgFlags++;
<a name="l00418"></a>00418     len = usbRead(<a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 1, wantLen);
<a name="l00419"></a>00419     <span class="keywordflow">if</span>(len &lt;= 8){           <span class="comment">/* valid data packet */</span>
<a name="l00420"></a>00420         <a class="code" href="usbdrv_2usbdrv_8h.html#96a513e4c0943ba6bd42aa1289874340">usbCrc16Append</a>(<a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 1, len);
<a name="l00421"></a>00421         txLen = len + 4;    <span class="comment">/* length including sync byte */</span>
<a name="l00422"></a>00422         <span class="keywordflow">if</span>(len &lt; 8)         <span class="comment">/* a partial package identifies end of message */</span>
<a name="l00423"></a>00423             <a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;
<a name="l00424"></a>00424     }<span class="keywordflow">else</span>{
<a name="l00425"></a>00425         token = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00426"></a>00426         txLen = 2;          <span class="comment">/* length including sync byte */</span>
<a name="l00427"></a>00427         <a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429     <a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[0] = token;
<a name="l00430"></a>00430     usbTxLen = txLen;
<a name="l00431"></a>00431 <span class="preprocessor">#if DEBUG_LEVEL &gt; 1</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x20, <a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>, txLen-1);
<a name="l00433"></a>00433 <span class="preprocessor">#else</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#1b3ae5f24b3863d451c3648fa2ff57be">DBG1</a>(0x20, <a class="code" href="usbdrv_2usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 1, 2);
<a name="l00435"></a>00435 <span class="preprocessor">#endif</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>}
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> isNotSE0(<span class="keywordtype">void</span>)
<a name="l00439"></a>00439 {
<a name="l00440"></a>00440 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>   rval;
<a name="l00441"></a>00441 <span class="comment">/* We want to do</span>
<a name="l00442"></a>00442 <span class="comment"> *     return (USBIN &amp; USBMASK);</span>
<a name="l00443"></a>00443 <span class="comment"> * here, but the compiler does int-expansion acrobatics.</span>
<a name="l00444"></a>00444 <span class="comment"> * We can avoid this by assigning to a char-sized variable.</span>
<a name="l00445"></a>00445 <span class="comment"> */</span>
<a name="l00446"></a>00446     rval = <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#85296740a603c928460d39ef9be869a4">USBIN</a> &amp; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#0140266b6db5af6ba9167f04a91ca076">USBMASK</a>;
<a name="l00447"></a>00447     <span class="keywordflow">return</span> rval;
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00451"></a>00451 
<a name="l00452"></a><a class="code" href="usbdrv_2usbdrv_8h.html#188162c29eb62ffbd2d33763d20e12b4">00452</a> <span class="keywordtype">void</span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#602c14b8f268adeae6896014c9a79909">usbPoll</a>(<span class="keywordtype">void</span>)
<a name="l00453"></a>00453 {
<a name="l00454"></a>00454 <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>   len;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="keywordflow">if</span>((len = usbRxLen) &gt; 0){
<a name="l00457"></a>00457 <span class="comment">/* We could check CRC16 here -- but ACK has already been sent anyway. If you</span>
<a name="l00458"></a>00458 <span class="comment"> * need data integrity checks with this driver, check the CRC in your app</span>
<a name="l00459"></a>00459 <span class="comment"> * code and report errors back to the host. Since the ACK was already sent,</span>
<a name="l00460"></a>00460 <span class="comment"> * retries must be handled on application level.</span>
<a name="l00461"></a>00461 <span class="comment"> * unsigned crc = usbCrc16((uchar *)(unsigned)(usbAppBuf + 1), usbRxLen - 3);</span>
<a name="l00462"></a>00462 <span class="comment"> */</span>
<a name="l00463"></a>00463         len -= 3;       <span class="comment">/* remove PID and CRC */</span>
<a name="l00464"></a>00464         <span class="keywordflow">if</span>(len &lt; 128){  <span class="comment">/* no overflow */</span>
<a name="l00465"></a>00465             <a class="code" href="unionconverter__t.html">converter_t</a> appBuf;
<a name="l00466"></a>00466             appBuf.<a class="code" href="unionconverter__t.html#6303c2a2b30bdd9ad5dacb62ef19682c">ptr</a> = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)<a class="code" href="usbdrv_2usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>;
<a name="l00467"></a>00467             appBuf.<a class="code" href="unionconverter__t.html#f1aa09c318011859f8ff23c5ccd18996">bytes</a>[0] = usbAppBuf;
<a name="l00468"></a>00468             appBuf.<a class="code" href="unionconverter__t.html#f1aa09c318011859f8ff23c5ccd18996">bytes</a>[0]++;
<a name="l00469"></a>00469             usbProcessRx(appBuf.<a class="code" href="unionconverter__t.html#6303c2a2b30bdd9ad5dacb62ef19682c">ptr</a>, len);
<a name="l00470"></a>00470         }
<a name="l00471"></a>00471         usbRxLen = 0;   <span class="comment">/* mark rx buffer as available */</span>
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473     <span class="keywordflow">if</span>(<a class="code" href="usbdrv_2usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> != 0xff){  <span class="comment">/* transmit data pending? */</span>
<a name="l00474"></a>00474         <span class="keywordflow">if</span>(usbTxLen &lt; 0)    <span class="comment">/* transmit system idle */</span>
<a name="l00475"></a>00475             usbBuildTxBlock();
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477     <span class="keywordflow">if</span>(isNotSE0()){ <span class="comment">/* SE0 state */</span>
<a name="l00478"></a>00478         usbIsReset = 0;
<a name="l00479"></a>00479     }<span class="keywordflow">else</span>{
<a name="l00480"></a>00480         <span class="comment">/* check whether SE0 lasts for more than 2.5us (3.75 bit times) */</span>
<a name="l00481"></a>00481         <span class="keywordflow">if</span>(!usbIsReset){
<a name="l00482"></a>00482             <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> i;
<a name="l00483"></a>00483             <span class="keywordflow">for</span>(i=100;i;i--){
<a name="l00484"></a>00484                 <span class="keywordflow">if</span>(isNotSE0())
<a name="l00485"></a>00485                     <span class="keywordflow">goto</span> notUsbReset;
<a name="l00486"></a>00486             }
<a name="l00487"></a>00487             usbIsReset = 1;
<a name="l00488"></a>00488             usbNewDeviceAddr = 0;
<a name="l00489"></a>00489             usbDeviceAddr = 0;
<a name="l00490"></a>00490 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00491"></a>00491 <span class="preprocessor"></span>            usbHalted1 = 0;
<a name="l00492"></a>00492 <span class="preprocessor">#endif</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>            <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#1b3ae5f24b3863d451c3648fa2ff57be">DBG1</a>(0xff, 0, 0);
<a name="l00494"></a>00494 notUsbReset:;
<a name="l00495"></a>00495         }
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00500"></a>00500 
<a name="l00501"></a><a class="code" href="usbdrv_2usbdrv_8h.html#5672a0c07f0f8e93bde4579d278e6307">00501</a> <span class="keywordtype">void</span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#4552b1c9fe142a402c84c15444d3d927">usbInit</a>(<span class="keywordtype">void</span>)
<a name="l00502"></a>00502 {
<a name="l00503"></a>00503     usbInputBuf = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="usbdrv_2usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>[0];
<a name="l00504"></a>00504     usbAppBuf = (<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="usbdrv_2usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>[1];
<a name="l00505"></a>00505 <span class="preprocessor">#if USB_INTR_CFG_SET != 0</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#34cb3bb685c3a6f9c8a63f3a948799b6">USB_INTR_CFG</a> |= <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ab47b4721030fcf7b773ab33f8e0f1c9">USB_INTR_CFG_SET</a>;
<a name="l00507"></a>00507 <span class="preprocessor">#endif</span>
<a name="l00508"></a>00508 <span class="preprocessor"></span><span class="preprocessor">#if USB_INTR_CFG_CLR != 0</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#34cb3bb685c3a6f9c8a63f3a948799b6">USB_INTR_CFG</a> &amp;= ~(<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#aaa3f824f11c2a5e75acb3841063120d">USB_INTR_CFG_CLR</a>);
<a name="l00510"></a>00510 <span class="preprocessor">#endif</span>
<a name="l00511"></a>00511 <span class="preprocessor"></span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#0259fea2ff25be5c0cd58cce07526f84">USB_INTR_ENABLE</a> |= (1 &lt;&lt; <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3d028bbfd2e3e723bba54a4ac8fd584c">USB_INTR_ENABLE_BIT</a>);
<a name="l00512"></a>00512 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="comment">/* ------------------------------------------------------------------------- */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 30 15:43:33 2009 for USB IR HID Device by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
