<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>USB IR HID Device: usbdrv/usbdrv.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>usbdrv/usbdrv.c</h1><a href="usbdrv_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Name: usbdrv.c</span>
<a name="l00002"></a>00002 <span class="comment"> * Project: AVR USB driver</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: Christian Starkjohann</span>
<a name="l00004"></a>00004 <span class="comment"> * Creation Date: 2004-12-29</span>
<a name="l00005"></a>00005 <span class="comment"> * Tabsize: 4</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH</span>
<a name="l00007"></a>00007 <span class="comment"> * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)</span>
<a name="l00008"></a>00008 <span class="comment"> * This Revision: $Id: usbdrv.c 530 2008-02-28 15:34:04Z cs $</span>
<a name="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="iarcompat_8h.html">iarcompat.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#ifndef __IAR_SYSTEMS_ICC__</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;avr/io.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#   include &lt;avr/pgmspace.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#endif</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="usbdrv_8h.html">usbdrv.h</a>"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "<a class="code" href="oddebug_8h.html">oddebug.h</a>"</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/*</span>
<a name="l00020"></a>00020 <span class="comment">General Description:</span>
<a name="l00021"></a>00021 <span class="comment">This module implements the C-part of the USB driver. See usbdrv.h for a</span>
<a name="l00022"></a>00022 <span class="comment">documentation of the entire driver.</span>
<a name="l00023"></a>00023 <span class="comment">*/</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* raw USB registers / interface to assembler code: */</span>
<a name="l00028"></a><a class="code" href="usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">00028</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>[2*<a class="code" href="usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];  <span class="comment">/* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */</span>
<a name="l00029"></a><a class="code" href="usbdrv_8c.html#6b0f7b83997deee705eb56462e3f1fce">00029</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#6b0f7b83997deee705eb56462e3f1fce">usbInputBufOffset</a>;  <span class="comment">/* offset in usbRxBuf used for low level receiving */</span>
<a name="l00030"></a><a class="code" href="usbdrv_8c.html#3f91a04b325ad5232d270839891e5856">00030</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a>;      <span class="comment">/* assigned during enumeration, defaults to 0 */</span>
<a name="l00031"></a><a class="code" href="usbdrv_8c.html#b9c08d1850db1e4d9feea687bc129425">00031</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#b9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a>;   <span class="comment">/* device ID which should be set after status phase */</span>
<a name="l00032"></a><a class="code" href="usbdrv_8h.html#a43502fd98afab29fcd5115c1f2c4067">00032</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#a43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a>;   <span class="comment">/* currently selected configuration. Administered by driver, but not used */</span>
<a name="l00033"></a><a class="code" href="usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">00033</a> <span class="keyword">volatile</span> <a class="code" href="usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">schar</a> <a class="code" href="usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">usbRxLen</a>;        <span class="comment">/* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */</span>
<a name="l00034"></a><a class="code" href="usbdrv_8c.html#e302a61abfeb0784f42a903dd44aad1e">00034</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#e302a61abfeb0784f42a903dd44aad1e">usbCurrentTok</a>;      <span class="comment">/* last token received or endpoint number for last OUT token if != 0 */</span>
<a name="l00035"></a><a class="code" href="usbdrv_8c.html#e2a9422baba7da8914129e0784ab2c05">00035</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#e2a9422baba7da8914129e0784ab2c05">usbRxToken</a>;         <span class="comment">/* token for data we received; or endpont number for last OUT */</span>
<a name="l00036"></a><a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">00036</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;   <span class="comment">/* remaining number of bytes, no msg to send if -1 (see usbMsgPtr) */</span>
<a name="l00037"></a><a class="code" href="usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">00037</a> <span class="keyword">volatile</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;   <span class="comment">/* number of bytes to transmit with next IN token or handshake token */</span>
<a name="l00038"></a><a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">00038</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[<a class="code" href="usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];<span class="comment">/* data to transmit with next IN, free if usbTxLen contains handshake token */</span>
<a name="l00039"></a>00039 <span class="preprocessor">#if USB_COUNT_SOF</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="keyword">volatile</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>  usbSofCount;    <span class="comment">/* incremented by assembler module every SOF */</span>
<a name="l00041"></a>00041 <span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00043"></a><a class="code" href="usbdrv_8h.html#6c1902650e72ac69e542d086df6fe43c">00043</a> <span class="preprocessor"></span><span class="keyword">volatile</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;  <span class="comment">/* TX count for endpoint 1 */</span>
<a name="l00044"></a><a class="code" href="usbdrv_8h.html#92ad467856cc7e0efeafcda41671ea75">00044</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#92ad467856cc7e0efeafcda41671ea75">usbTxBuf1</a>[<a class="code" href="usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];     <span class="comment">/* TX data for endpoint 1 */</span>
<a name="l00045"></a>00045 <span class="preprocessor">#   if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="keyword">volatile</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> usbTxLen3 = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;  <span class="comment">/* TX count for endpoint 3 */</span>
<a name="l00047"></a>00047 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8h.html#3718ffde6726c22774878fb2aa4a3822">usbTxBuf3</a>[<a class="code" href="usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];     <span class="comment">/* TX data for endpoint 3 */</span>
<a name="l00048"></a>00048 <span class="preprocessor">#   endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="comment">/* USB status registers / not shared with asm code */</span>
<a name="l00052"></a><a class="code" href="usbdrv_8h.html#5f78c8584830588b8c0c8f2a27772f8e">00052</a> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>           *<a class="code" href="usbdrv_8c.html#5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a>;     <span class="comment">/* data to transmit next -- ROM or RAM address */</span>
<a name="l00053"></a>00053 <span class="keyword">static</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    usbMsgFlags;    <span class="comment">/* flag values see below */</span>
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="usbdrv_8c.html#2a36a35f900ede87e7c897bc778065c8">00055</a> <span class="preprocessor">#define USB_FLG_TX_PACKET       (1&lt;&lt;0)</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="comment">/* Leave free 6 bits after TX_PACKET. This way we can increment usbMsgFlags to toggle TX_PACKET */</span>
<a name="l00057"></a><a class="code" href="usbdrv_8c.html#06db19dbad17d54fc6f3742ab0afba69">00057</a> <span class="preprocessor">#define USB_FLG_MSGPTR_IS_ROM   (1&lt;&lt;6)</span>
<a name="l00058"></a><a class="code" href="usbdrv_8c.html#5e3bb8fb87bbde80118c36559bf41bcb">00058</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_FLG_USE_DEFAULT_RW  (1&lt;&lt;7)</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="comment">/*</span>
<a name="l00061"></a>00061 <span class="comment">optimizing hints:</span>
<a name="l00062"></a>00062 <span class="comment">- do not post/pre inc/dec integer values in operations</span>
<a name="l00063"></a>00063 <span class="comment">- assign value of PRG_RDB() to register variables and don't use side effects in arg</span>
<a name="l00064"></a>00064 <span class="comment">- use narrow scope for variables which should be in X/Y/Z register</span>
<a name="l00065"></a>00065 <span class="comment">- assign char sized expressions to variables to force 8 bit arithmetics</span>
<a name="l00066"></a>00066 <span class="comment">*/</span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRINGS == 0</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_0 == 0</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_0</span>
<a name="l00074"></a><a class="code" href="usbdrv_8c.html#9c0556a4c6c5a1ab8f6598aee8e5bf6a">00074</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)</span>
<a name="l00075"></a><a class="code" href="usbdrv_8h.html#c16de84418d64a0e74a4e551fc9ac786">00075</a> <span class="preprocessor"></span><a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">char</span> <a class="code" href="usbdrv_8c.html#c16de84418d64a0e74a4e551fc9ac786">usbDescriptorString0</a>[] = { <span class="comment">/* language descriptor */</span>
<a name="l00076"></a>00076     4,          <span class="comment">/* sizeof(usbDescriptorString0): length of descriptor in bytes */</span>
<a name="l00077"></a>00077     3,          <span class="comment">/* descriptor type */</span>
<a name="l00078"></a>00078     0x09, 0x04, <span class="comment">/* language index (0x0409 = US-English) */</span>
<a name="l00079"></a>00079 };
<a name="l00080"></a>00080 <span class="preprocessor">#endif</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 &amp;&amp; USB_CFG_VENDOR_NAME_LEN</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_VENDOR</span>
<a name="l00084"></a><a class="code" href="usbdrv_8c.html#55edf2117128387162339d98ba2af0f4">00084</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)</span>
<a name="l00085"></a><a class="code" href="usbdrv_8h.html#9974e0350b3ad7adafc3b1f0a47278ca">00085</a> <span class="preprocessor"></span><a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">int</span>  <a class="code" href="usbdrv_8c.html#9974e0350b3ad7adafc3b1f0a47278ca">usbDescriptorStringVendor</a>[] = {
<a name="l00086"></a>00086     <a class="code" href="usbdrv_8h.html#d94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(<a class="code" href="usbconfig_8h.html#3085d820d9dc6e939737a3f1b9a457d7">USB_CFG_VENDOR_NAME_LEN</a>),
<a name="l00087"></a>00087     <a class="code" href="usbconfig_8h.html#25a2baf5c8feb0982a47050423add0ec">USB_CFG_VENDOR_NAME</a>
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 <span class="preprocessor">#endif</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>
<a name="l00091"></a>00091 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 &amp;&amp; USB_CFG_DEVICE_NAME_LEN</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT</span>
<a name="l00093"></a><a class="code" href="usbdrv_8c.html#a08084f9755a643e02d469b66b129ef6">00093</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)</span>
<a name="l00094"></a><a class="code" href="usbdrv_8h.html#030c4d21be999d0deafccc65499a44df">00094</a> <span class="preprocessor"></span><a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">int</span>  <a class="code" href="usbdrv_8c.html#030c4d21be999d0deafccc65499a44df">usbDescriptorStringDevice</a>[] = {
<a name="l00095"></a>00095     <a class="code" href="usbdrv_8h.html#d94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(<a class="code" href="usbconfig_8h.html#e68f17e6baf13805abc56e74beadeb57">USB_CFG_DEVICE_NAME_LEN</a>),
<a name="l00096"></a>00096     <a class="code" href="usbconfig_8h.html#9b482a2b2740652ffe7dcb6695ca0c91">USB_CFG_DEVICE_NAME</a>
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 <span class="preprocessor">#endif</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>
<a name="l00100"></a>00100 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 &amp;&amp; defined(USB_CFG_SERIAL_NUMBER_LEN)</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">int</span> <a class="code" href="usbdrv_8h.html#04e6662c39d818a0c4ae16db46276194">usbDescriptorStringSerialNumber</a>[] = {
<a name="l00104"></a>00104     <a class="code" href="usbdrv_8h.html#d94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(USB_CFG_SERIAL_NUMBER_LEN),
<a name="l00105"></a>00105     USB_CFG_SERIAL_NUMBER
<a name="l00106"></a>00106 };
<a name="l00107"></a>00107 <span class="preprocessor">#endif</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>
<a name="l00109"></a>00109 <span class="preprocessor">#endif  </span><span class="comment">/* USB_CFG_DESCR_PROPS_STRINGS == 0 */</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_DEVICE == 0</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_DEVICE</span>
<a name="l00113"></a><a class="code" href="usbdrv_8c.html#a916bf33f6f8f481a219d0a81b5b225e">00113</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)</span>
<a name="l00114"></a><a class="code" href="usbdrv_8h.html#4832dd2433bcc12b444a31dc4a8bfc49">00114</a> <span class="preprocessor"></span><a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">char</span> <a class="code" href="usbdrv_8c.html#4832dd2433bcc12b444a31dc4a8bfc49">usbDescriptorDevice</a>[] = {    <span class="comment">/* USB device descriptor */</span>
<a name="l00115"></a>00115     18,         <span class="comment">/* sizeof(usbDescriptorDevice): length of descriptor in bytes */</span>
<a name="l00116"></a>00116     <a class="code" href="usbdrv_8h.html#5b76593f7b6295a4a599aba4476ec258">USBDESCR_DEVICE</a>,        <span class="comment">/* descriptor type */</span>
<a name="l00117"></a>00117     0x10, 0x01,             <span class="comment">/* USB version supported */</span>
<a name="l00118"></a>00118     <a class="code" href="usbconfig_8h.html#9ce4f96ad98b3db8205691e8bc723e55">USB_CFG_DEVICE_CLASS</a>,
<a name="l00119"></a>00119     <a class="code" href="usbconfig_8h.html#89e5ad66f8b835866e7d836c73bfd30d">USB_CFG_DEVICE_SUBCLASS</a>,
<a name="l00120"></a>00120     0,                      <span class="comment">/* protocol */</span>
<a name="l00121"></a>00121     8,                      <span class="comment">/* max packet size */</span>
<a name="l00122"></a>00122     <span class="comment">/* the following two casts affect the first byte of the constant only, but</span>
<a name="l00123"></a>00123 <span class="comment">     * that's sufficient to avoid a warning with the default values.</span>
<a name="l00124"></a>00124 <span class="comment">     */</span>
<a name="l00125"></a>00125     (char)<a class="code" href="usbconfig_8h.html#9326b8ec9f809ce66d54349691646930">USB_CFG_VENDOR_ID</a>,<span class="comment">/* 2 bytes */</span>
<a name="l00126"></a>00126     (<span class="keywordtype">char</span>)<a class="code" href="usbconfig_8h.html#bc740455309399430b0f49bf7931d1d7">USB_CFG_DEVICE_ID</a>,<span class="comment">/* 2 bytes */</span>
<a name="l00127"></a>00127     <a class="code" href="usbconfig_8h.html#ba3c7c0cd4055ba3bbf5df38e57b6d27">USB_CFG_DEVICE_VERSION</a>, <span class="comment">/* 2 bytes */</span>
<a name="l00128"></a>00128     <a class="code" href="usbconfig_8h.html#55edf2117128387162339d98ba2af0f4">USB_CFG_DESCR_PROPS_STRING_VENDOR</a> != 0 ? 1 : 0,         <span class="comment">/* manufacturer string index */</span>
<a name="l00129"></a>00129     <a class="code" href="usbconfig_8h.html#a08084f9755a643e02d469b66b129ef6">USB_CFG_DESCR_PROPS_STRING_PRODUCT</a> != 0 ? 2 : 0,        <span class="comment">/* product string index */</span>
<a name="l00130"></a>00130     <a class="code" href="usbconfig_8h.html#82224c07d3a1f9fcccbff70b71c8ea51">USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER</a> != 0 ? 3 : 0,  <span class="comment">/* serial number string index */</span>
<a name="l00131"></a>00131     1,          <span class="comment">/* number of configurations */</span>
<a name="l00132"></a>00132 };
<a name="l00133"></a>00133 <span class="preprocessor">#endif</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 &amp;&amp; USB_CFG_DESCR_PROPS_HID == 0</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_HID</span>
<a name="l00137"></a><a class="code" href="usbdrv_8c.html#dfbd53b5310c36b1e4b06d6a3b992e8a">00137</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_HID     9   </span><span class="comment">/* length of HID descriptor in config descriptor below */</span>
<a name="l00138"></a>00138 <span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>
<a name="l00140"></a>00140 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_CONFIGURATION</span>
<a name="l00142"></a><a class="code" href="usbdrv_8c.html#8aae9f682ca9f91faae0453e4351a50b">00142</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)</span>
<a name="l00143"></a><a class="code" href="usbdrv_8h.html#86288669b638000acf9548272f73e7f6">00143</a> <span class="preprocessor"></span><a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">char</span> <a class="code" href="usbdrv_8c.html#86288669b638000acf9548272f73e7f6">usbDescriptorConfiguration</a>[] = {    <span class="comment">/* USB configuration descriptor */</span>
<a name="l00144"></a>00144     9,          <span class="comment">/* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */</span>
<a name="l00145"></a>00145     <a class="code" href="usbdrv_8h.html#6ff1081ad7212a0c7009ef5b79f3669f">USBDESCR_CONFIG</a>,    <span class="comment">/* descriptor type */</span>
<a name="l00146"></a>00146     18 + 7 * <a class="code" href="usbconfig_8h.html#fe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a> + (<a class="code" href="usbconfig_8h.html#dfbd53b5310c36b1e4b06d6a3b992e8a">USB_CFG_DESCR_PROPS_HID</a> &amp; 0xff), 0,
<a name="l00147"></a>00147                 <span class="comment">/* total length of data returned (including inlined descriptors) */</span>
<a name="l00148"></a>00148     1,          <span class="comment">/* number of interfaces in this configuration */</span>
<a name="l00149"></a>00149     1,          <span class="comment">/* index of this configuration */</span>
<a name="l00150"></a>00150     0,          <span class="comment">/* configuration name string index */</span>
<a name="l00151"></a>00151 #<span class="keywordflow">if</span> <a class="code" href="usbconfig_8h.html#d5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a>
<a name="l00152"></a>00152     <a class="code" href="usbdrv_8h.html#fa0dd9c06af4b033461ba3c755ca90bb">USBATTR_SELFPOWER</a>,      <span class="comment">/* attributes */</span>
<a name="l00153"></a>00153 #<span class="keywordflow">else</span>
<a name="l00154"></a>00154     (<span class="keywordtype">char</span>)<a class="code" href="usbdrv_8h.html#9731bc516bc018f3b0f50a455d5a5681">USBATTR_BUSPOWER</a>, <span class="comment">/* attributes */</span>
<a name="l00155"></a>00155 <span class="preprocessor">#endif</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span>    <a class="code" href="usbconfig_8h.html#be324d9b00dc186bcbac65ed0f94811c">USB_CFG_MAX_BUS_POWER</a>/2,            <span class="comment">/* max USB current in 2mA units */</span>
<a name="l00157"></a>00157 <span class="comment">/* interface descriptor follows inline: */</span>
<a name="l00158"></a>00158     9,          <span class="comment">/* sizeof(usbDescrInterface): length of descriptor in bytes */</span>
<a name="l00159"></a>00159     <a class="code" href="usbdrv_8h.html#1ce81e6fb124d8747018b4343faa65ba">USBDESCR_INTERFACE</a>, <span class="comment">/* descriptor type */</span>
<a name="l00160"></a>00160     0,          <span class="comment">/* index of this interface */</span>
<a name="l00161"></a>00161     0,          <span class="comment">/* alternate setting for this interface */</span>
<a name="l00162"></a>00162     <a class="code" href="usbconfig_8h.html#fe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a>,   <span class="comment">/* endpoints excl 0: number of endpoint descriptors to follow */</span>
<a name="l00163"></a>00163     <a class="code" href="usbconfig_8h.html#34f6fe9486b66e8220a82a0eb87a7447">USB_CFG_INTERFACE_CLASS</a>,
<a name="l00164"></a>00164     <a class="code" href="usbconfig_8h.html#c643f27afa43062c19b8f0674b6be1b5">USB_CFG_INTERFACE_SUBCLASS</a>,
<a name="l00165"></a>00165     <a class="code" href="usbconfig_8h.html#8ddab89b764bfd88d024c7d9c9931de3">USB_CFG_INTERFACE_PROTOCOL</a>,
<a name="l00166"></a>00166     0,          <span class="comment">/* string index for interface */</span>
<a name="l00167"></a>00167 <span class="preprocessor">#if (USB_CFG_DESCR_PROPS_HID &amp; 0xff)    </span><span class="comment">/* HID descriptor */</span>
<a name="l00168"></a>00168     9,          <span class="comment">/* sizeof(usbDescrHID): length of descriptor in bytes */</span>
<a name="l00169"></a>00169     <a class="code" href="usbdrv_8h.html#de4fe1fba6aca94a379fdbacbbcc6800">USBDESCR_HID</a>,   <span class="comment">/* descriptor type: HID */</span>
<a name="l00170"></a>00170     0x01, 0x01, <span class="comment">/* BCD representation of HID version */</span>
<a name="l00171"></a>00171     0x00,       <span class="comment">/* target country code */</span>
<a name="l00172"></a>00172     0x01,       <span class="comment">/* number of HID Report (or other HID class) Descriptor infos to follow */</span>
<a name="l00173"></a>00173     0x22,       <span class="comment">/* descriptor type: report */</span>
<a name="l00174"></a>00174     <a class="code" href="usbconfig_8h.html#47d9bef5c10a1b9ba917eca583d2abc9">USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH</a>, 0,  <span class="comment">/* total length of report descriptor */</span>
<a name="l00175"></a>00175 <span class="preprocessor">#endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT    </span><span class="comment">/* endpoint descriptor for endpoint 1 */</span>
<a name="l00177"></a>00177     7,          <span class="comment">/* sizeof(usbDescrEndpoint) */</span>
<a name="l00178"></a>00178     <a class="code" href="usbdrv_8h.html#b2c475dbe374ed8bc514893fb97a6083">USBDESCR_ENDPOINT</a>,  <span class="comment">/* descriptor type = endpoint */</span>
<a name="l00179"></a>00179     (char)0x81, <span class="comment">/* IN endpoint number 1 */</span>
<a name="l00180"></a>00180     0x03,       <span class="comment">/* attrib: Interrupt endpoint */</span>
<a name="l00181"></a>00181     8, 0,       <span class="comment">/* maximum packet size */</span>
<a name="l00182"></a>00182     <a class="code" href="usbconfig_8h.html#9cccddfefa62f926a0d7bba9f183a4d3">USB_CFG_INTR_POLL_INTERVAL</a>, <span class="comment">/* in ms */</span>
<a name="l00183"></a>00183 #endif
<a name="l00184"></a>00184 };
<a name="l00185"></a>00185 <span class="preprocessor">#endif</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>
<a name="l00187"></a>00187 <span class="comment">/* We don't use prog_int or prog_int16_t for compatibility with various libc</span>
<a name="l00188"></a>00188 <span class="comment"> * versions. Here's an other compatibility hack:</span>
<a name="l00189"></a>00189 <span class="comment"> */</span>
<a name="l00190"></a>00190 <span class="preprocessor">#ifndef PRG_RDB</span>
<a name="l00191"></a><a class="code" href="usbdrv_8c.html#f7c7b7892c3be6693e9107a0b4e1a75e">00191</a> <span class="preprocessor"></span><span class="preprocessor">#define PRG_RDB(addr)   pgm_read_byte(addr)</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>
<a name="l00194"></a><a class="code" href="unionconverter__t.html">00194</a> <span class="keyword">typedef</span> <span class="keyword">union</span>{
<a name="l00195"></a><a class="code" href="unionconverter__t.html#a838a8d4780d6cd64701379b48591efd">00195</a>     <span class="keywordtype">unsigned</span>    word;
<a name="l00196"></a><a class="code" href="unionconverter__t.html#11647bd73801c57c9f2c19f525a25356">00196</a>     <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       *ptr;
<a name="l00197"></a><a class="code" href="unionconverter__t.html#f9e702bd1d8fc9d346745cb66d47fe33">00197</a>     <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       bytes[2];
<a name="l00198"></a>00198 }<a class="code" href="unionconverter__t.html">converter_t</a>;
<a name="l00199"></a>00199 <span class="comment">/* We use this union to do type conversions. This is better optimized than</span>
<a name="l00200"></a>00200 <span class="comment"> * type casts in gcc 3.4.3 and much better than using bit shifts to build</span>
<a name="l00201"></a>00201 <span class="comment"> * ints from chars. Byte ordering is not a problem on an 8 bit platform.</span>
<a name="l00202"></a>00202 <span class="comment"> */</span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>  usbResetDataToggling(<span class="keywordtype">void</span>)
<a name="l00207"></a>00207 {
<a name="l00208"></a>00208 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#ca823e3f6e7e9b50d59f00a1099fdcf5">USB_SET_DATATOKEN1</a>(<a class="code" href="usbdrv_8h.html#0890d166b64c89804154892c992bb8a9">USB_INITIAL_DATATOKEN</a>);  <span class="comment">/* reset data toggling for interrupt endpoint */</span>
<a name="l00210"></a>00210 <span class="preprocessor">#   if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#88a3c0e0377c62f13d123a536a112adf">USB_SET_DATATOKEN3</a>(<a class="code" href="usbdrv_8h.html#0890d166b64c89804154892c992bb8a9">USB_INITIAL_DATATOKEN</a>);  <span class="comment">/* reset data toggling for interrupt endpoint */</span>
<a name="l00212"></a>00212 <span class="preprocessor">#   endif</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>}
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>  usbResetStall(<span class="keywordtype">void</span>)
<a name="l00217"></a>00217 {
<a name="l00218"></a>00218 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT &amp;&amp; USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>        <a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;
<a name="l00220"></a>00220 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>        usbTxLen3 = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;
<a name="l00222"></a>00222 <span class="preprocessor">#endif</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>}
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00229"></a><a class="code" href="usbdrv_8h.html#afa474a799eed02d362bfdfb8a36602c">00229</a> <span class="preprocessor"></span>USB_PUBLIC <span class="keywordtype">void</span> <a class="code" href="usbdrv_8c.html#afa474a799eed02d362bfdfb8a36602c">usbSetInterrupt</a>(<a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       *p, i;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> == <a class="code" href="usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>)
<a name="l00235"></a>00235         <span class="keywordflow">return</span>;
<a name="l00236"></a>00236 <span class="preprocessor">#endif</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span><span class="preprocessor">#if 0   </span><span class="comment">/* No runtime checks! Caller is responsible for valid data! */</span>
<a name="l00238"></a>00238     <span class="keywordflow">if</span>(len &gt; 8) <span class="comment">/* interrupt transfers are limited to 8 bytes */</span>
<a name="l00239"></a>00239         len = 8;
<a name="l00240"></a>00240 <span class="preprocessor">#endif</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> &amp; 0x10){   <span class="comment">/* packet buffer was empty */</span>
<a name="l00242"></a>00242         <a class="code" href="usbdrv_8c.html#92ad467856cc7e0efeafcda41671ea75">usbTxBuf1</a>[0] ^= <a class="code" href="usbdrv_8h.html#ddf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a> ^ <a class="code" href="usbdrv_8h.html#62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>;    <span class="comment">/* toggle token */</span>
<a name="l00243"></a>00243     }<span class="keywordflow">else</span>{
<a name="l00244"></a>00244         <a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>; <span class="comment">/* avoid sending outdated (overwritten) interrupt data */</span>
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246     p = <a class="code" href="usbdrv_8c.html#92ad467856cc7e0efeafcda41671ea75">usbTxBuf1</a> + 1;
<a name="l00247"></a>00247     <span class="keywordflow">for</span>(i=len;i--;)
<a name="l00248"></a>00248         *p++ = *data++;
<a name="l00249"></a>00249     <a class="code" href="usbdrv_8h.html#96a513e4c0943ba6bd42aa1289874340">usbCrc16Append</a>(&amp;<a class="code" href="usbdrv_8c.html#92ad467856cc7e0efeafcda41671ea75">usbTxBuf1</a>[1], len);
<a name="l00250"></a>00250     <a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> = len + 4;    <span class="comment">/* len must be given including sync byte */</span>
<a name="l00251"></a>00251     <a class="code" href="oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x21, <a class="code" href="usbdrv_8c.html#92ad467856cc7e0efeafcda41671ea75">usbTxBuf1</a>, len + 3);
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 <span class="preprocessor">#endif</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>
<a name="l00255"></a>00255 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span>USB_PUBLIC <span class="keywordtype">void</span> usbSetInterrupt3(<a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       *p, i;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     <span class="keywordflow">if</span>(usbTxLen3 &amp; 0x10){   <span class="comment">/* packet buffer was empty */</span>
<a name="l00261"></a>00261         <a class="code" href="usbdrv_8h.html#3718ffde6726c22774878fb2aa4a3822">usbTxBuf3</a>[0] ^= <a class="code" href="usbdrv_8h.html#ddf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a> ^ <a class="code" href="usbdrv_8h.html#62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>;    <span class="comment">/* toggle token */</span>
<a name="l00262"></a>00262     }<span class="keywordflow">else</span>{
<a name="l00263"></a>00263         usbTxLen3 = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>; <span class="comment">/* avoid sending outdated (overwritten) interrupt data */</span>
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265     p = <a class="code" href="usbdrv_8h.html#3718ffde6726c22774878fb2aa4a3822">usbTxBuf3</a> + 1;
<a name="l00266"></a>00266     <span class="keywordflow">for</span>(i=len;i--;)
<a name="l00267"></a>00267         *p++ = *data++;
<a name="l00268"></a>00268     <a class="code" href="usbdrv_8h.html#96a513e4c0943ba6bd42aa1289874340">usbCrc16Append</a>(&amp;usbTxBuf3[1], len);
<a name="l00269"></a>00269     usbTxLen3 = len + 4;    <span class="comment">/* len must be given including sync byte */</span>
<a name="l00270"></a>00270     <a class="code" href="oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x23, usbTxBuf3, len + 3);
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 <span class="preprocessor">#endif</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keyword">static</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> usbRead(<a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00276"></a>00276 {
<a name="l00277"></a>00277 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="usbdrv_8c.html#5e3bb8fb87bbde80118c36559bf41bcb">USB_FLG_USE_DEFAULT_RW</a>){
<a name="l00279"></a>00279 <span class="preprocessor">#endif</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>        <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> i = len, *r = <a class="code" href="usbdrv_8c.html#5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a>;
<a name="l00281"></a>00281         <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="usbdrv_8c.html#06db19dbad17d54fc6f3742ab0afba69">USB_FLG_MSGPTR_IS_ROM</a>){    <span class="comment">/* ROM data */</span>
<a name="l00282"></a>00282             <span class="keywordflow">while</span>(i--){
<a name="l00283"></a>00283                 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> c = <a class="code" href="usbdrv_8c.html#f7c7b7892c3be6693e9107a0b4e1a75e">PRG_RDB</a>(r);    <span class="comment">/* assign to char size variable to enforce byte ops */</span>
<a name="l00284"></a>00284                 *data++ = c;
<a name="l00285"></a>00285                 r++;
<a name="l00286"></a>00286             }
<a name="l00287"></a>00287         }<span class="keywordflow">else</span>{                  <span class="comment">/* RAM data */</span>
<a name="l00288"></a>00288             <span class="keywordflow">while</span>(i--)
<a name="l00289"></a>00289                 *data++ = *r++;
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291         <a class="code" href="usbdrv_8c.html#5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a> = r;
<a name="l00292"></a>00292         <span class="keywordflow">return</span> len;
<a name="l00293"></a>00293 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>    }<span class="keywordflow">else</span>{
<a name="l00295"></a>00295         <span class="keywordflow">if</span>(len != 0)    <span class="comment">/* don't bother app with 0 sized reads */</span>
<a name="l00296"></a>00296             <span class="keywordflow">return</span> usbFunctionRead(data, len);
<a name="l00297"></a>00297         <span class="keywordflow">return</span> 0;
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299 <span class="preprocessor">#endif</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>}
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a><a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">00303</a> <span class="preprocessor">#define GET_DESCRIPTOR(cfgProp, staticName)         \</span>
<a name="l00304"></a>00304 <span class="preprocessor">    if(cfgProp){                                    \</span>
<a name="l00305"></a>00305 <span class="preprocessor">        if((cfgProp) &amp; USB_PROP_IS_RAM)             \</span>
<a name="l00306"></a>00306 <span class="preprocessor">            flags &amp;= ~USB_FLG_MSGPTR_IS_ROM;        \</span>
<a name="l00307"></a>00307 <span class="preprocessor">        if((cfgProp) &amp; USB_PROP_IS_DYNAMIC){        \</span>
<a name="l00308"></a>00308 <span class="preprocessor">            replyLen = usbFunctionDescriptor(rq);   \</span>
<a name="l00309"></a>00309 <span class="preprocessor">        }else{                                      \</span>
<a name="l00310"></a>00310 <span class="preprocessor">            replyData = (uchar *)(staticName);      \</span>
<a name="l00311"></a>00311 <span class="preprocessor">            SET_REPLY_LEN((cfgProp) &amp; 0xff);        \</span>
<a name="l00312"></a>00312 <span class="preprocessor">        }                                           \</span>
<a name="l00313"></a>00313 <span class="preprocessor">    }</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span><span class="comment">/* We use if() instead of #if in the macro above because #if can't be used</span>
<a name="l00315"></a>00315 <span class="comment"> * in macros and the compiler optimizes constant conditions anyway.</span>
<a name="l00316"></a>00316 <span class="comment"> */</span>
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">/* Don't make this function static to avoid inlining.</span>
<a name="l00320"></a>00320 <span class="comment"> * The entire function would become too large and exceed the range of</span>
<a name="l00321"></a>00321 <span class="comment"> * relative jumps.</span>
<a name="l00322"></a>00322 <span class="comment"> * 2006-02-25: Either gcc 3.4.3 is better than the gcc used when the comment</span>
<a name="l00323"></a>00323 <span class="comment"> * above was written, or other parts of the code have changed. We now get</span>
<a name="l00324"></a>00324 <span class="comment"> * better results with an inlined function. Test condition: PowerSwitch code.</span>
<a name="l00325"></a>00325 <span class="comment"> */</span>
<a name="l00326"></a>00326 <span class="keyword">static</span> <span class="keywordtype">void</span> usbProcessRx(<a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00327"></a>00327 {
<a name="l00328"></a>00328 <a class="code" href="structusbRequest.html">usbRequest_t</a>    *rq = (<span class="keywordtype">void</span> *)data;
<a name="l00329"></a>00329 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>           replyLen = 0, flags = USB_FLG_USE_DEFAULT_RW;
<a name="l00330"></a>00330 <span class="comment">/* We use if() cascades because the compare is done byte-wise while switch()</span>
<a name="l00331"></a>00331 <span class="comment"> * is int-based. The if() cascades are therefore more efficient.</span>
<a name="l00332"></a>00332 <span class="comment"> */</span>
<a name="l00333"></a>00333 <span class="comment">/* usbRxToken can be:</span>
<a name="l00334"></a>00334 <span class="comment"> * 0x2d 00101101 (USBPID_SETUP for endpoint 0)</span>
<a name="l00335"></a>00335 <span class="comment"> * 0xe1 11100001 (USBPID_OUT for endpoint 0)</span>
<a name="l00336"></a>00336 <span class="comment"> * 0xff 11111111 (USBPID_OUT for endpoint 1)</span>
<a name="l00337"></a>00337 <span class="comment"> */</span>
<a name="l00338"></a>00338     <a class="code" href="oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x10 + ((<a class="code" href="usbdrv_8c.html#e2a9422baba7da8914129e0784ab2c05">usbRxToken</a> &gt;&gt; 1) &amp; 3), data, len);    <span class="comment">/* SETUP0=12; OUT0=10; OUT1=13 */</span>
<a name="l00339"></a>00339 <span class="preprocessor">#ifdef USB_RX_USER_HOOK</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span>    USB_RX_USER_HOOK(data, len)
<a name="l00341"></a>00341 <span class="preprocessor">#endif</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_WRITEOUT</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#e2a9422baba7da8914129e0784ab2c05">usbRxToken</a> &lt; 0x10){  <span class="comment">/* endpoint number in usbRxToken */</span>
<a name="l00344"></a>00344         usbFunctionWriteOut(data, len);
<a name="l00345"></a>00345         <span class="keywordflow">return</span>; <span class="comment">/* no reply expected, hence no usbMsgPtr, usbMsgFlags, usbMsgLen set */</span>
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347 <span class="preprocessor">#endif</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#e2a9422baba7da8914129e0784ab2c05">usbRxToken</a> == (<a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="usbdrv_8h.html#3e2083acfa1300227dce323ca04db880">USBPID_SETUP</a>){
<a name="l00349"></a>00349         <a class="code" href="usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;  <span class="comment">/* abort pending transmit */</span>
<a name="l00350"></a>00350         <span class="keywordflow">if</span>(len == 8){   <span class="comment">/* Setup size must be always 8 bytes. Ignore otherwise. */</span>
<a name="l00351"></a>00351             <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> type = rq-&gt;<a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="usbdrv_8h.html#ef7b9c4cc4266e79c677fd42e2abb40e">USBRQ_TYPE_MASK</a>;
<a name="l00352"></a>00352             <span class="keywordflow">if</span>(type == <a class="code" href="usbdrv_8h.html#a2eaf9447ddfc30442e8b6bd13cfd969">USBRQ_TYPE_STANDARD</a>){
<a name="l00353"></a>00353 <span class="preprocessor">                #define SET_REPLY_LEN(len)  replyLen = (len); usbMsgPtr = replyData</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>                <span class="comment">/* This macro ensures that replyLen and usbMsgPtr are always set in the same way.</span>
<a name="l00355"></a>00355 <span class="comment">                 * That allows optimization of common code in if() branches */</span>
<a name="l00356"></a>00356                 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *replyData = <a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 9; <span class="comment">/* there is 3 bytes free space at the end of the buffer */</span>
<a name="l00357"></a>00357                 replyData[0] = 0;   <span class="comment">/* common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */</span>
<a name="l00358"></a>00358                 <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#523252bd739d1b14018ec34e49466d72">USBRQ_GET_STATUS</a>){           <span class="comment">/* 0 */</span>
<a name="l00359"></a>00359                     <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> __attribute__((__unused__)) recipient = rq-&gt;<a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="usbdrv_8h.html#5ae0c6cdfa26c87300c3a01aa2b0c7e2">USBRQ_RCPT_MASK</a>;  <span class="comment">/* assign arith ops to variables to enforce byte size */</span>
<a name="l00360"></a>00360 <span class="preprocessor">#if USB_CFG_IS_SELF_POWERED</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>                    <span class="keywordflow">if</span>(recipient == <a class="code" href="usbdrv_8h.html#eb145a6378e20ee3aedaa81fffd08d5d">USBRQ_RCPT_DEVICE</a>)
<a name="l00362"></a>00362                         replyData[0] =  <a class="code" href="usbconfig_8h.html#d5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a>;
<a name="l00363"></a>00363 <span class="preprocessor">#endif</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT &amp;&amp; USB_CFG_IMPLEMENT_HALT</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span>                    <span class="keywordflow">if</span>(recipient == <a class="code" href="usbdrv_8h.html#6c25d62097af881d30af436c07773a26">USBRQ_RCPT_ENDPOINT</a> &amp;&amp; rq-&gt;<a class="code" href="structusbRequest.html#efa059246bf079d5b42af148a2ad6a95">wIndex</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 0x81)   <span class="comment">/* request status for endpoint 1 */</span>
<a name="l00366"></a>00366                         replyData[0] = <a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> == <a class="code" href="usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00367"></a>00367 <span class="preprocessor">#endif</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span>                    replyData[1] = 0;
<a name="l00369"></a>00369                     <a class="code" href="usbdrv_8c.html#466c165427ebc11a0a9fb48deb3fe54e">SET_REPLY_LEN</a>(2);
<a name="l00370"></a>00370                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#6837bf1e17c56a25b97db0be68b03519">USBRQ_SET_ADDRESS</a>){    <span class="comment">/* 5 */</span>
<a name="l00371"></a>00371                     <a class="code" href="usbdrv_8c.html#b9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a> = rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00372"></a>00372 <span class="preprocessor">#ifdef USB_SET_ADDRESS_HOOK</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>                    USB_SET_ADDRESS_HOOK();
<a name="l00374"></a>00374 <span class="preprocessor">#endif</span>
<a name="l00375"></a>00375 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#225b041572762941a96694d5498e853e">USBRQ_GET_DESCRIPTOR</a>){ <span class="comment">/* 6 */</span>
<a name="l00376"></a>00376                     flags = USB_FLG_MSGPTR_IS_ROM | USB_FLG_USE_DEFAULT_RW;
<a name="l00377"></a>00377                     <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[1] == <a class="code" href="usbdrv_8h.html#5b76593f7b6295a4a599aba4476ec258">USBDESCR_DEVICE</a>){ <span class="comment">/* 1 */</span>
<a name="l00378"></a>00378                         <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#a916bf33f6f8f481a219d0a81b5b225e">USB_CFG_DESCR_PROPS_DEVICE</a>, <a class="code" href="usbdrv_8c.html#4832dd2433bcc12b444a31dc4a8bfc49">usbDescriptorDevice</a>)
<a name="l00379"></a>00379                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[1] == <a class="code" href="usbdrv_8h.html#6ff1081ad7212a0c7009ef5b79f3669f">USBDESCR_CONFIG</a>){   <span class="comment">/* 2 */</span>
<a name="l00380"></a>00380                         <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#8aae9f682ca9f91faae0453e4351a50b">USB_CFG_DESCR_PROPS_CONFIGURATION</a>, <a class="code" href="usbdrv_8c.html#86288669b638000acf9548272f73e7f6">usbDescriptorConfiguration</a>)
<a name="l00381"></a>00381                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[1] == <a class="code" href="usbdrv_8h.html#abd48b46ba597bd32ce5c64a7aad23c4">USBDESCR_STRING</a>){   <span class="comment">/* 3 */</span>
<a name="l00382"></a>00382 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRINGS &amp; USB_PROP_IS_DYNAMIC</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>                        <span class="keywordflow">if</span>(<a class="code" href="usbconfig_8h.html#750fb6cc3e8eafaddae659af97f6f737">USB_CFG_DESCR_PROPS_STRINGS</a> &amp; <a class="code" href="usbdrv_8h.html#316a7fbfdf2ffb5155980cb14f93d53d">USB_PROP_IS_RAM</a>)
<a name="l00384"></a>00384                             flags &amp;= ~USB_FLG_MSGPTR_IS_ROM;
<a name="l00385"></a>00385                         replyLen = <a class="code" href="usbdrv_8h.html#ede5c83b3ad4c5e4795d9ba6add8f01c">usbFunctionDescriptor</a>(rq);
<a name="l00386"></a>00386 <span class="preprocessor">#else   </span><span class="comment">/* USB_CFG_DESCR_PROPS_STRINGS &amp; USB_PROP_IS_DYNAMIC */</span>
<a name="l00387"></a>00387                         <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 0){   <span class="comment">/* descriptor index */</span>
<a name="l00388"></a>00388                             <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#9c0556a4c6c5a1ab8f6598aee8e5bf6a">USB_CFG_DESCR_PROPS_STRING_0</a>, <a class="code" href="usbdrv_8c.html#c16de84418d64a0e74a4e551fc9ac786">usbDescriptorString0</a>)
<a name="l00389"></a>00389                         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 1){
<a name="l00390"></a>00390                             <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#55edf2117128387162339d98ba2af0f4">USB_CFG_DESCR_PROPS_STRING_VENDOR</a>, <a class="code" href="usbdrv_8c.html#9974e0350b3ad7adafc3b1f0a47278ca">usbDescriptorStringVendor</a>)
<a name="l00391"></a>00391                         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 2){
<a name="l00392"></a>00392                             <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#a08084f9755a643e02d469b66b129ef6">USB_CFG_DESCR_PROPS_STRING_PRODUCT</a>, <a class="code" href="usbdrv_8c.html#030c4d21be999d0deafccc65499a44df">usbDescriptorStringDevice</a>)
<a name="l00393"></a>00393                         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 3){
<a name="l00394"></a>00394                             <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#82224c07d3a1f9fcccbff70b71c8ea51">USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER</a>, <a class="code" href="usbdrv_8h.html#04e6662c39d818a0c4ae16db46276194">usbDescriptorStringSerialNumber</a>)
<a name="l00395"></a>00395                         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usbconfig_8h.html#3c9ed2d932cf0f5fc9788a91028a8b4b">USB_CFG_DESCR_PROPS_UNKNOWN</a> &amp; <a class="code" href="usbdrv_8h.html#25fffb901b71f003f9d90c411f998b36">USB_PROP_IS_DYNAMIC</a>){
<a name="l00396"></a>00396                             replyLen = <a class="code" href="usbdrv_8h.html#ede5c83b3ad4c5e4795d9ba6add8f01c">usbFunctionDescriptor</a>(rq);
<a name="l00397"></a>00397                         }
<a name="l00398"></a>00398 <span class="preprocessor">#endif  </span><span class="comment">/* USB_CFG_DESCR_PROPS_STRINGS &amp; USB_PROP_IS_DYNAMIC */</span>
<a name="l00399"></a>00399 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_HID_REPORT  </span><span class="comment">/* only support HID descriptors if enabled */</span>
<a name="l00400"></a>00400                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[1] == USBDESCR_HID){          <span class="comment">/* 0x21 */</span>
<a name="l00401"></a>00401                         <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#dfbd53b5310c36b1e4b06d6a3b992e8a">USB_CFG_DESCR_PROPS_HID</a>, <a class="code" href="usbdrv_8c.html#86288669b638000acf9548272f73e7f6">usbDescriptorConfiguration</a> + 18)
<a name="l00402"></a>00402                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[1] == <a class="code" href="usbdrv_8h.html#f2ef6d7e2fe214a3d3a14f5419550bb0">USBDESCR_HID_REPORT</a>){   <span class="comment">/* 0x22 */</span>
<a name="l00403"></a>00403                         <a class="code" href="usbdrv_8c.html#4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#248eae427d6cea0046661eb8438b7198">USB_CFG_DESCR_PROPS_HID_REPORT</a>, <a class="code" href="usbdrv_8h.html#5f6ed8eed333942ed365ab158f2f1871">usbDescriptorHidReport</a>)
<a name="l00404"></a>00404 <span class="preprocessor">#endif  </span><span class="comment">/* USB_CFG_DESCR_PROPS_HID_REPORT */</span>
<a name="l00405"></a>00405                     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="usbconfig_8h.html#3c9ed2d932cf0f5fc9788a91028a8b4b">USB_CFG_DESCR_PROPS_UNKNOWN</a> &amp; <a class="code" href="usbdrv_8h.html#25fffb901b71f003f9d90c411f998b36">USB_PROP_IS_DYNAMIC</a>){
<a name="l00406"></a>00406                         replyLen = <a class="code" href="usbdrv_8h.html#ede5c83b3ad4c5e4795d9ba6add8f01c">usbFunctionDescriptor</a>(rq);
<a name="l00407"></a>00407                     }
<a name="l00408"></a>00408                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#16d2228bcfa8944c18a39df43016cea5">USBRQ_GET_CONFIGURATION</a>){  <span class="comment">/* 8 */</span>
<a name="l00409"></a>00409                     replyData = &amp;<a class="code" href="usbdrv_8c.html#a43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a>;  <span class="comment">/* send current configuration value */</span>
<a name="l00410"></a>00410                     <a class="code" href="usbdrv_8c.html#466c165427ebc11a0a9fb48deb3fe54e">SET_REPLY_LEN</a>(1);
<a name="l00411"></a>00411                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#fc6adbbfd47da950ccf50277a41bfe58">USBRQ_SET_CONFIGURATION</a>){  <span class="comment">/* 9 */</span>
<a name="l00412"></a>00412                     <a class="code" href="usbdrv_8c.html#a43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a> = rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00413"></a>00413                     usbResetStall();
<a name="l00414"></a>00414                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#44a94b5f45d9ffb957b9590eea8a73a4">USBRQ_GET_INTERFACE</a>){      <span class="comment">/* 10 */</span>
<a name="l00415"></a>00415                     <a class="code" href="usbdrv_8c.html#466c165427ebc11a0a9fb48deb3fe54e">SET_REPLY_LEN</a>(1);
<a name="l00416"></a>00416 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#904cc1bbdd859501d590ce47099a49ec">USBRQ_SET_INTERFACE</a>){      <span class="comment">/* 11 */</span>
<a name="l00418"></a>00418                     usbResetDataToggling();
<a name="l00419"></a>00419                     usbResetStall();
<a name="l00420"></a>00420 <span class="preprocessor">#   if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#82766d6fb4294e1cb5f7cb2086e81715">USBRQ_CLEAR_FEATURE</a> || rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#1802461b0f91708022a66f407fadd1f1">USBRQ_SET_FEATURE</a>){   <span class="comment">/* 1|3 */</span>
<a name="l00422"></a>00422                     <span class="keywordflow">if</span>(rq-&gt;<a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 0 &amp;&amp; rq-&gt;<a class="code" href="structusbRequest.html#efa059246bf079d5b42af148a2ad6a95">wIndex</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0] == 0x81){   <span class="comment">/* feature 0 == HALT for endpoint == 1 */</span>
<a name="l00423"></a>00423                         <a class="code" href="usbdrv_8c.html#6c1902650e72ac69e542d086df6fe43c">usbTxLen1</a> = rq-&gt;<a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#82766d6fb4294e1cb5f7cb2086e81715">USBRQ_CLEAR_FEATURE</a> ? <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a> : <a class="code" href="usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00424"></a>00424                         usbResetDataToggling();
<a name="l00425"></a>00425                     }
<a name="l00426"></a>00426 <span class="preprocessor">#   endif</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>                }<span class="keywordflow">else</span>{
<a name="l00429"></a>00429                     <span class="comment">/* the following requests can be ignored, send default reply */</span>
<a name="l00430"></a>00430                     <span class="comment">/* 1: CLEAR_FEATURE, 3: SET_FEATURE, 7: SET_DESCRIPTOR */</span>
<a name="l00431"></a>00431                     <span class="comment">/* 12: SYNCH_FRAME */</span>
<a name="l00432"></a>00432                 }
<a name="l00433"></a>00433 <span class="preprocessor">                #undef SET_REPLY_LEN</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>            }<span class="keywordflow">else</span>{  <span class="comment">/* not a standard request -- must be vendor or class request */</span>
<a name="l00435"></a>00435                 replyLen = <a class="code" href="main_8c.html#e6f351eca7bf6fb1251f9a478cbae2b0">usbFunctionSetup</a>(data);
<a name="l00436"></a>00436             }
<a name="l00437"></a>00437 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(replyLen == 0xff){   <span class="comment">/* use user-supplied read/write function */</span>
<a name="l00439"></a>00439                 <span class="keywordflow">if</span>((rq-&gt;<a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="usbdrv_8h.html#7754f61bfa2e16800aa396896092f50a">USBRQ_DIR_MASK</a>) == <a class="code" href="usbdrv_8h.html#04a0c4970f7371115638586bc8a14325">USBRQ_DIR_DEVICE_TO_HOST</a>){
<a name="l00440"></a>00440                     replyLen = rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0];    <span class="comment">/* IN transfers only */</span>
<a name="l00441"></a>00441                 }
<a name="l00442"></a>00442                 flags &amp;= ~USB_FLG_USE_DEFAULT_RW;  <span class="comment">/* we have no valid msg, use user supplied read/write functions */</span>
<a name="l00443"></a>00443             }<span class="keywordflow">else</span>   <span class="comment">/* The 'else' prevents that we limit a replyLen of 0xff to the maximum transfer len. */</span>
<a name="l00444"></a>00444 <span class="preprocessor">#endif</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[1] &amp;&amp; replyLen &gt; rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0])  <span class="comment">/* limit length to max */</span>
<a name="l00446"></a>00446                 replyLen = rq-&gt;<a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         <span class="comment">/* make sure that data packets which are sent as ACK to an OUT transfer are always zero sized */</span>
<a name="l00449"></a>00449     }<span class="keywordflow">else</span>{  <span class="comment">/* DATA packet from out request */</span>
<a name="l00450"></a>00450 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!(usbMsgFlags &amp; USB_FLG_USE_DEFAULT_RW)){
<a name="l00452"></a>00452             <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> rval = usbFunctionWrite(data, len);
<a name="l00453"></a>00453             replyLen = 0xff;
<a name="l00454"></a>00454             <span class="keywordflow">if</span>(rval == 0xff){       <span class="comment">/* an error occurred */</span>
<a name="l00455"></a>00455                 <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;   <span class="comment">/* cancel potentially pending data packet for ACK */</span>
<a name="l00456"></a>00456                 <a class="code" href="usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = <a class="code" href="usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00457"></a>00457             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rval != 0){    <span class="comment">/* This was the final package */</span>
<a name="l00458"></a>00458                 replyLen = 0;       <span class="comment">/* answer with a zero-sized data packet */</span>
<a name="l00459"></a>00459             }
<a name="l00460"></a>00460             flags = 0;    <span class="comment">/* start with a DATA1 package, stay with user supplied write() function */</span>
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462 <span class="preprocessor">#endif</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>    }
<a name="l00464"></a>00464     usbMsgFlags = flags;
<a name="l00465"></a>00465     <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = replyLen;
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="keyword">static</span> <span class="keywordtype">void</span> usbBuildTxBlock(<span class="keywordtype">void</span>)
<a name="l00471"></a>00471 {
<a name="l00472"></a>00472 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>   wantLen, len, txLen, token;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     wantLen = <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a>;
<a name="l00475"></a>00475     <span class="keywordflow">if</span>(wantLen &gt; 8)
<a name="l00476"></a>00476         wantLen = 8;
<a name="l00477"></a>00477     <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> -= wantLen;
<a name="l00478"></a>00478     token = <a class="code" href="usbdrv_8h.html#62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>;
<a name="l00479"></a>00479     <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="usbdrv_8c.html#2a36a35f900ede87e7c897bc778065c8">USB_FLG_TX_PACKET</a>)
<a name="l00480"></a>00480         token = <a class="code" href="usbdrv_8h.html#ddf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a>;
<a name="l00481"></a>00481     usbMsgFlags++;
<a name="l00482"></a>00482     len = usbRead(<a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 1, wantLen);
<a name="l00483"></a>00483     <span class="keywordflow">if</span>(len &lt;= 8){           <span class="comment">/* valid data packet */</span>
<a name="l00484"></a>00484         <a class="code" href="usbdrv_8h.html#96a513e4c0943ba6bd42aa1289874340">usbCrc16Append</a>(&amp;<a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[1], len);
<a name="l00485"></a>00485         txLen = len + 4;    <span class="comment">/* length including sync byte */</span>
<a name="l00486"></a>00486         <span class="keywordflow">if</span>(len &lt; 8)         <span class="comment">/* a partial package identifies end of message */</span>
<a name="l00487"></a>00487             <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;
<a name="l00488"></a>00488     }<span class="keywordflow">else</span>{
<a name="l00489"></a>00489         txLen = <a class="code" href="usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;   <span class="comment">/* stall the endpoint */</span>
<a name="l00490"></a>00490         <a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> = 0xff;
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492     <a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[0] = token;
<a name="l00493"></a>00493     <a class="code" href="usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = txLen;
<a name="l00494"></a>00494     <a class="code" href="oddebug_8h.html#6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x20, <a class="code" href="usbdrv_8c.html#2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>, txLen-1);
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> isNotSE0(<span class="keywordtype">void</span>)
<a name="l00500"></a>00500 {
<a name="l00501"></a>00501 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>   rval;
<a name="l00502"></a>00502 <span class="comment">/* We want to do</span>
<a name="l00503"></a>00503 <span class="comment"> *     return (USBIN &amp; USBMASK);</span>
<a name="l00504"></a>00504 <span class="comment"> * here, but the compiler does int-expansion acrobatics.</span>
<a name="l00505"></a>00505 <span class="comment"> * We can avoid this by assigning to a char-sized variable.</span>
<a name="l00506"></a>00506 <span class="comment"> */</span>
<a name="l00507"></a>00507     rval = <a class="code" href="usbdrv_8h.html#85296740a603c928460d39ef9be869a4">USBIN</a> &amp; <a class="code" href="usbdrv_8h.html#0140266b6db5af6ba9167f04a91ca076">USBMASK</a>;
<a name="l00508"></a>00508     <span class="keywordflow">return</span> rval;
<a name="l00509"></a>00509 }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> usbHandleResetHook(<a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> notResetState)
<a name="l00512"></a>00512 {
<a name="l00513"></a>00513 <span class="preprocessor">#ifdef USB_RESET_HOOK</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    wasReset;
<a name="l00515"></a>00515 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>           isReset = !notResetState;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     <span class="keywordflow">if</span>(wasReset != isReset){
<a name="l00518"></a>00518         USB_RESET_HOOK(isReset);
<a name="l00519"></a>00519         wasReset = isReset;
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521 <span class="preprocessor">#endif</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span>}
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00525"></a>00525 
<a name="l00526"></a><a class="code" href="usbdrv_8h.html#188162c29eb62ffbd2d33763d20e12b4">00526</a> USB_PUBLIC <span class="keywordtype">void</span> <a class="code" href="usbdrv_8c.html#188162c29eb62ffbd2d33763d20e12b4">usbPoll</a>(<span class="keywordtype">void</span>)
<a name="l00527"></a>00527 {
<a name="l00528"></a>00528 <a class="code" href="usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">schar</a>   len;
<a name="l00529"></a>00529 <a class="code" href="oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>   i;
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="keywordflow">if</span>((len = <a class="code" href="usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">usbRxLen</a>) &gt; 0){
<a name="l00532"></a>00532 <span class="comment">/* We could check CRC16 here -- but ACK has already been sent anyway. If you</span>
<a name="l00533"></a>00533 <span class="comment"> * need data integrity checks with this driver, check the CRC in your app</span>
<a name="l00534"></a>00534 <span class="comment"> * code and report errors back to the host. Since the ACK was already sent,</span>
<a name="l00535"></a>00535 <span class="comment"> * retries must be handled on application level.</span>
<a name="l00536"></a>00536 <span class="comment"> * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);</span>
<a name="l00537"></a>00537 <span class="comment"> */</span>
<a name="l00538"></a>00538         usbProcessRx(<a class="code" href="usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a> + <a class="code" href="usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a> + 1 - <a class="code" href="usbdrv_8c.html#6b0f7b83997deee705eb56462e3f1fce">usbInputBufOffset</a>, len - 3);
<a name="l00539"></a>00539 <span class="preprocessor">#if USB_CFG_HAVE_FLOWCONTROL</span>
<a name="l00540"></a>00540 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> &gt; 0)    <span class="comment">/* only mark as available if not inactivated */</span>
<a name="l00541"></a>00541             <a class="code" href="usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> = 0;
<a name="l00542"></a>00542 <span class="preprocessor">#else</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>        <a class="code" href="usbdrv_8c.html#3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> = 0;       <span class="comment">/* mark rx buffer as available */</span>
<a name="l00544"></a>00544 <span class="preprocessor">#endif</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span>    }
<a name="l00546"></a>00546     <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> &amp; 0x10){ <span class="comment">/* transmit system idle */</span>
<a name="l00547"></a>00547         <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#5d017abeeddd393d4abda00257c73930">usbMsgLen</a> != 0xff){  <span class="comment">/* transmit data pending? */</span>
<a name="l00548"></a>00548             usbBuildTxBlock();
<a name="l00549"></a>00549         }
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551     <span class="keywordflow">for</span>(i = 10; i &gt; 0; i--){
<a name="l00552"></a>00552         <span class="keywordflow">if</span>(isNotSE0())
<a name="l00553"></a>00553             <span class="keywordflow">break</span>;
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555     <span class="keywordflow">if</span>(i == 0){ <span class="comment">/* RESET condition, called multiple times during reset */</span>
<a name="l00556"></a>00556         <a class="code" href="usbdrv_8c.html#b9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a> = 0;
<a name="l00557"></a>00557         <a class="code" href="usbdrv_8c.html#3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a> = 0;
<a name="l00558"></a>00558         usbResetStall();
<a name="l00559"></a>00559         <a class="code" href="oddebug_8h.html#1b3ae5f24b3863d451c3648fa2ff57be">DBG1</a>(0xff, 0, 0);
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561     usbHandleResetHook(i);
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00565"></a>00565 
<a name="l00566"></a><a class="code" href="usbdrv_8h.html#5672a0c07f0f8e93bde4579d278e6307">00566</a> USB_PUBLIC <span class="keywordtype">void</span> <a class="code" href="usbdrv_8c.html#5672a0c07f0f8e93bde4579d278e6307">usbInit</a>(<span class="keywordtype">void</span>)
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568 <span class="preprocessor">#if USB_INTR_CFG_SET != 0</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#34cb3bb685c3a6f9c8a63f3a948799b6">USB_INTR_CFG</a> |= <a class="code" href="usbdrv_8h.html#ab47b4721030fcf7b773ab33f8e0f1c9">USB_INTR_CFG_SET</a>;
<a name="l00570"></a>00570 <span class="preprocessor">#endif</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span><span class="preprocessor">#if USB_INTR_CFG_CLR != 0</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#34cb3bb685c3a6f9c8a63f3a948799b6">USB_INTR_CFG</a> &amp;= ~(<a class="code" href="usbdrv_8h.html#aaa3f824f11c2a5e75acb3841063120d">USB_INTR_CFG_CLR</a>);
<a name="l00573"></a>00573 <span class="preprocessor">#endif</span>
<a name="l00574"></a>00574 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#0259fea2ff25be5c0cd58cce07526f84">USB_INTR_ENABLE</a> |= (1 &lt;&lt; <a class="code" href="usbdrv_8h.html#3d028bbfd2e3e723bba54a4ac8fd584c">USB_INTR_ENABLE_BIT</a>);
<a name="l00575"></a>00575     usbResetDataToggling();
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="comment">/* ------------------------------------------------------------------------- */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 30 20:43:20 2009 for USB IR HID Device by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
