<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>USB IR HID Device: bootloader_firmware/usbdrv/usbdrv.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>bootloader_firmware/usbdrv/usbdrv.h</h1><a href="bootloader__firmware_2usbdrv_2usbdrv_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Name: usbdrv.h</span>
<a name="l00002"></a>00002 <span class="comment"> * Project: AVR USB driver</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: Christian Starkjohann</span>
<a name="l00004"></a>00004 <span class="comment"> * Creation Date: 2004-12-29</span>
<a name="l00005"></a>00005 <span class="comment"> * Tabsize: 4</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH</span>
<a name="l00007"></a>00007 <span class="comment"> * License: Proprietary, free under certain conditions. See Documentation.</span>
<a name="l00008"></a>00008 <span class="comment"> * This Revision: $Id: usbdrv.h 158 2006-03-14 15:34:17Z cs $</span>
<a name="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#ifndef __usbdrv_h_included__</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#define __usbdrv_h_included__</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="usbconfig_8h.html">usbconfig.h</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="bootloader__firmware_2usbdrv_2iarcompat_8h.html">iarcompat.h</a>"</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="comment">/*</span>
<a name="l00017"></a>00017 <span class="comment">Hardware Prerequisites:</span>
<a name="l00018"></a>00018 <span class="comment">=======================</span>
<a name="l00019"></a>00019 <span class="comment">USB lines D+ and D- MUST be wired to the same I/O port. Line D- MUST be wired</span>
<a name="l00020"></a>00020 <span class="comment">to bit number 0. D+ must also be connected to INT0. D- requires a pullup of</span>
<a name="l00021"></a>00021 <span class="comment">1.5k to +3.5V (and the device must be powered at 3.5V) to identify as</span>
<a name="l00022"></a>00022 <span class="comment">low-speed USB device. A pullup of 1M SHOULD be connected from D+ to +3.5V to</span>
<a name="l00023"></a>00023 <span class="comment">prevent interference when no USB master is connected. We use D+ as interrupt</span>
<a name="l00024"></a>00024 <span class="comment">source and not D- because it does not trigger on keep-alive and RESET states.</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">As a compile time option, the 1.5k pullup resistor on D- can be made</span>
<a name="l00027"></a>00027 <span class="comment">switchable to allow the device to disconnect at will. See the definition of</span>
<a name="l00028"></a>00028 <span class="comment">usbDeviceConnect() and usbDeviceDisconnect() further down in this file.</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">Please adapt the values in usbconfig.h according to your hardware!</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">The device MUST be clocked at 12 MHz. This is more than the 10 MHz allowed by</span>
<a name="l00033"></a>00033 <span class="comment">an AT90S2313 powered at 4.5V. However, if the supply voltage to maximum clock</span>
<a name="l00034"></a>00034 <span class="comment">relation is interpolated linearly, an ATtiny2313 meets the requirement by</span>
<a name="l00035"></a>00035 <span class="comment">specification. In practice, the AT90S2313 can be overclocked and works well.</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">Limitations:</span>
<a name="l00039"></a>00039 <span class="comment">============</span>
<a name="l00040"></a>00040 <span class="comment">Compiling:</span>
<a name="l00041"></a>00041 <span class="comment">You should link the usbdrv.o module first because it has special alignment</span>
<a name="l00042"></a>00042 <span class="comment">requirements for the receive buffer (the buffer must not cross a 256 byte</span>
<a name="l00043"></a>00043 <span class="comment">page boundary, it must not even touch it at the end). If you can't link it</span>
<a name="l00044"></a>00044 <span class="comment">first, you must use other measures to ensure alignment.</span>
<a name="l00045"></a>00045 <span class="comment">Note: gcc does not always assign variable addresses in the order as the modules</span>
<a name="l00046"></a>00046 <span class="comment">are linked or the variables are declared. You can choose a memory section for</span>
<a name="l00047"></a>00047 <span class="comment">the receive buffer with the configuration option "USB_BUFFER_SECTION". This</span>
<a name="l00048"></a>00048 <span class="comment">option defaults to ".bss". If you use your own section, you can place it at</span>
<a name="l00049"></a>00049 <span class="comment">an arbitrary location with a linker option similar to</span>
<a name="l00050"></a>00050 <span class="comment">"-Wl,--section-start=.mybuffer=0x800060". Use "avr-nm -ng" on the binary and</span>
<a name="l00051"></a>00051 <span class="comment">search for "usbRxBuf" to find tbe base address of the 22 bytes rx buffer.</span>
<a name="l00052"></a>00052 <span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">Robustness with respect to communication errors:</span>
<a name="l00054"></a>00054 <span class="comment">The driver assumes error-free communication. It DOES check for errors in</span>
<a name="l00055"></a>00055 <span class="comment">the PID, but does NOT check bit stuffing errors, SE0 in middle of a byte,</span>
<a name="l00056"></a>00056 <span class="comment">token CRC (5 bit) and data CRC (16 bit). CRC checks can not be performed due</span>
<a name="l00057"></a>00057 <span class="comment">to timing constraints: We must start sending a reply within 7 bit times.</span>
<a name="l00058"></a>00058 <span class="comment">Bit stuffing and misplaced SE0 would have to be checked in real-time, but CPU</span>
<a name="l00059"></a>00059 <span class="comment">performance does not permit that. The driver does not check Data0/Data1</span>
<a name="l00060"></a>00060 <span class="comment">toggling, but application software can implement the check.</span>
<a name="l00061"></a>00061 <span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">Sampling jitter:</span>
<a name="l00063"></a>00063 <span class="comment">The driver guarantees a sampling window of 1/2 bit. The USB spec requires</span>
<a name="l00064"></a>00064 <span class="comment">that the receiver has at most 1/4 bit sampling window. The 1/2 bit window</span>
<a name="l00065"></a>00065 <span class="comment">should still work reliably enough because we work at low speed. If you want</span>
<a name="l00066"></a>00066 <span class="comment">to meet the spec, define the macro "USB_CFG_SAMPLE_EXACT" to 1 in usbconfig.h.</span>
<a name="l00067"></a>00067 <span class="comment">This will unroll a loop which results in bigger code size.</span>
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">Input characteristics:</span>
<a name="l00070"></a>00070 <span class="comment">Since no differential receiver circuit is used, electrical interference</span>
<a name="l00071"></a>00071 <span class="comment">robustness may suffer. The driver samples only one of the data lines with</span>
<a name="l00072"></a>00072 <span class="comment">an ordinary I/O pin's input characteristics. However, since this is only a</span>
<a name="l00073"></a>00073 <span class="comment">low speed USB implementation and the specification allows for 8 times the</span>
<a name="l00074"></a>00074 <span class="comment">bit rate over the same hardware, we should be on the safe side. Even the spec</span>
<a name="l00075"></a>00075 <span class="comment">requires detection of asymmetric states at high bit rate for SE0 detection.</span>
<a name="l00076"></a>00076 <span class="comment"></span>
<a name="l00077"></a>00077 <span class="comment">Number of endpoints:</span>
<a name="l00078"></a>00078 <span class="comment">The driver supports up to two endpoints: One control endpoint (endpoint 0) and</span>
<a name="l00079"></a>00079 <span class="comment">one interrupt-in endpoint (endpoint 1) where the device can send interrupt</span>
<a name="l00080"></a>00080 <span class="comment">data to the host. Endpoint 1 is only compiled in if</span>
<a name="l00081"></a>00081 <span class="comment">USB_CFG_HAVE_INTRIN_ENDPOINT is defined to 1 in usbconfig.h.</span>
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">Maximum data payload:</span>
<a name="l00084"></a>00084 <span class="comment">Data payload of control in and out transfers may be up to 254 bytes. In order</span>
<a name="l00085"></a>00085 <span class="comment">to accept payload data of out transfers, you need to implement</span>
<a name="l00086"></a>00086 <span class="comment">'usbFunctionWrite()'.</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">USB Suspend Mode supply current:</span>
<a name="l00089"></a>00089 <span class="comment">The USB standard limits power consumption to 500uA when the bus is in suspend</span>
<a name="l00090"></a>00090 <span class="comment">mode. This is not a problem for self-powered devices since they don't need</span>
<a name="l00091"></a>00091 <span class="comment">bus power anyway. Bus-powered devices can achieve this only by putting the</span>
<a name="l00092"></a>00092 <span class="comment">CPU in sleep mode. The driver does not implement suspend handling by itself.</span>
<a name="l00093"></a>00093 <span class="comment">However, the application may implement activity monitoring and wakeup from</span>
<a name="l00094"></a>00094 <span class="comment">sleep. The host sends regular SE0 states on the bus to keep it active. These</span>
<a name="l00095"></a>00095 <span class="comment">SE0 states can be detected by wiring the INT1 pin to D+. It is not necessary</span>
<a name="l00096"></a>00096 <span class="comment">to enable the interrupt, checking the interrupt pending flag should suffice.</span>
<a name="l00097"></a>00097 <span class="comment">Before entering sleep mode, the application should enable INT1 for a wakeup</span>
<a name="l00098"></a>00098 <span class="comment">on the next bus activity.</span>
<a name="l00099"></a>00099 <span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">Operation without an USB master:</span>
<a name="l00101"></a>00101 <span class="comment">The driver behaves neutral without connection to an USB master if D- reads</span>
<a name="l00102"></a>00102 <span class="comment">as 1. To avoid spurious interrupts, we recommend a high impedance (e.g. 1M)</span>
<a name="l00103"></a>00103 <span class="comment">pullup resistor on D+. If D- becomes statically 0, the driver may block in</span>
<a name="l00104"></a>00104 <span class="comment">the interrupt routine.</span>
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">Interrupt latency:</span>
<a name="l00107"></a>00107 <span class="comment">The application must ensure that the USB interrupt is not disabled for more</span>
<a name="l00108"></a>00108 <span class="comment">than 20 cycles. This implies that all interrupt routines must either be</span>
<a name="l00109"></a>00109 <span class="comment">declared as "INTERRUPT" instead of "SIGNAL" (see "avr/signal.h") or that they</span>
<a name="l00110"></a>00110 <span class="comment">are written in assembler with "sei" as the first instruction.</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">Maximum interrupt duration / CPU cycle consumption:</span>
<a name="l00113"></a>00113 <span class="comment">The driver handles all USB communication during the interrupt service</span>
<a name="l00114"></a>00114 <span class="comment">routine. The routine will not return before an entire USB message is received</span>
<a name="l00115"></a>00115 <span class="comment">and the reply is sent. This may be up to ca. 1200 cycles = 100us if the host</span>
<a name="l00116"></a>00116 <span class="comment">conforms to the standard. The driver will consume CPU cycles for all USB</span>
<a name="l00117"></a>00117 <span class="comment">messages, even if they address another (low-speed) device on the same bus.</span>
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment">*/</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00122"></a>00122 <span class="comment">/* --------------------------- Module Interface ---------------------------- */</span>
<a name="l00123"></a>00123 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#938381382a94d1c945b7233fcfa78e0e">00125</a> <span class="preprocessor">#define USBDRV_VERSION  20060314</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="comment">/* This define uniquely identifies a driver version. It is a decimal number</span>
<a name="l00127"></a>00127 <span class="comment"> * constructed from the driver's release date in the form YYYYMMDD. If the</span>
<a name="l00128"></a>00128 <span class="comment"> * driver's behavior or interface changes, you can use this constant to</span>
<a name="l00129"></a>00129 <span class="comment"> * distinguish versions. If it is not defined, the driver's release date is</span>
<a name="l00130"></a>00130 <span class="comment"> * older than 2006-01-25.</span>
<a name="l00131"></a>00131 <span class="comment"> */</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="preprocessor">#ifndef __ASSEMBLER__</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>
<a name="l00135"></a>00135 <span class="preprocessor">#ifndef uchar</span>
<a name="l00136"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#a8ddf20cdd716b652e76e23e5e700893">00136</a> <span class="preprocessor"></span><span class="preprocessor">#define uchar   unsigned char</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">#ifndef schar</span>
<a name="l00139"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">00139</a> <span class="preprocessor"></span><span class="preprocessor">#define schar   signed char</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="comment">/* shortcuts for well defined 8 bit integer types */</span>
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="keyword">extern</span> <span class="keywordtype">void</span>     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#4552b1c9fe142a402c84c15444d3d927">usbInit</a>(<span class="keywordtype">void</span>);
<a name="l00144"></a>00144 <span class="comment">/* This function must be called before interrupts are enabled and the main</span>
<a name="l00145"></a>00145 <span class="comment"> * loop is entered.</span>
<a name="l00146"></a>00146 <span class="comment"> */</span>
<a name="l00147"></a>00147 <span class="keyword">extern</span> <span class="keywordtype">void</span>     <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#602c14b8f268adeae6896014c9a79909">usbPoll</a>(<span class="keywordtype">void</span>);
<a name="l00148"></a>00148 <span class="comment">/* This function must be called at regular intervals from the main loop.</span>
<a name="l00149"></a>00149 <span class="comment"> * Maximum delay between calls is somewhat less than 50ms (USB timeout for</span>
<a name="l00150"></a>00150 <span class="comment"> * accepting a Setup message). Otherwise the device will not be recognized.</span>
<a name="l00151"></a>00151 <span class="comment"> * Please note that debug outputs through the UART take ~ 0.5ms per byte</span>
<a name="l00152"></a>00152 <span class="comment"> * at 19200 bps.</span>
<a name="l00153"></a>00153 <span class="comment"> */</span>
<a name="l00154"></a>00154 <span class="keyword">extern</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    *<a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a>;
<a name="l00155"></a>00155 <span class="comment">/* This variable may be used to pass transmit data to the driver from the</span>
<a name="l00156"></a>00156 <span class="comment"> * implementation of usbFunctionWrite(). It is also used internally by the</span>
<a name="l00157"></a>00157 <span class="comment"> * driver for standard control requests.</span>
<a name="l00158"></a>00158 <span class="comment"> */</span>
<a name="l00159"></a>00159 <span class="keyword">extern</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    <a class="code" href="bootloader__firmware_2main_8c.html#e6f351eca7bf6fb1251f9a478cbae2b0">usbFunctionSetup</a>(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> data[8]);
<a name="l00160"></a>00160 <span class="comment">/* This function is called when the driver receives a SETUP transaction from</span>
<a name="l00161"></a>00161 <span class="comment"> * the host which is not answered by the driver itself (in practice: class and</span>
<a name="l00162"></a>00162 <span class="comment"> * vendor requests). All control transfers start with a SETUP transaction where</span>
<a name="l00163"></a>00163 <span class="comment"> * the host communicates the parameters of the following (optional) data</span>
<a name="l00164"></a>00164 <span class="comment"> * transfer. The SETUP data is available in the 'data' parameter which can</span>
<a name="l00165"></a>00165 <span class="comment"> * (and should) be casted to 'usbRequest_t *' for a more user-friendly access</span>
<a name="l00166"></a>00166 <span class="comment"> * to parameters.</span>
<a name="l00167"></a>00167 <span class="comment"> *</span>
<a name="l00168"></a>00168 <span class="comment"> * If the SETUP indicates a control-in transfer, you should provide the</span>
<a name="l00169"></a>00169 <span class="comment"> * requested data to the driver. There are two ways to transfer this data:</span>
<a name="l00170"></a>00170 <span class="comment"> * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data</span>
<a name="l00171"></a>00171 <span class="comment"> * block and return the length of the data in 'usbFunctionSetup()'. The driver</span>
<a name="l00172"></a>00172 <span class="comment"> * will handle the rest. Or (2) return 0xff in 'usbFunctionSetup()'. The driver</span>
<a name="l00173"></a>00173 <span class="comment"> * will then call 'usbFunctionRead()' when data is needed. See the</span>
<a name="l00174"></a>00174 <span class="comment"> * documentation for usbFunctionRead() for details.</span>
<a name="l00175"></a>00175 <span class="comment"> *</span>
<a name="l00176"></a>00176 <span class="comment"> * If the SETUP indicates a control-out transfer, the only way to receive the</span>
<a name="l00177"></a>00177 <span class="comment"> * data from the host is through the 'usbFunctionWrite()' call. If you</span>
<a name="l00178"></a>00178 <span class="comment"> * implement this function, you must return 0xff in 'usbFunctionSetup()' to</span>
<a name="l00179"></a>00179 <span class="comment"> * indicate that 'usbFunctionWrite()' should be used. See the documentation of</span>
<a name="l00180"></a>00180 <span class="comment"> * this function for more information. If you just want to ignore the data sent</span>
<a name="l00181"></a>00181 <span class="comment"> * by the host, return 0 in 'usbFunctionSetup()'.</span>
<a name="l00182"></a>00182 <span class="comment"> *</span>
<a name="l00183"></a>00183 <span class="comment"> * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()</span>
<a name="l00184"></a>00184 <span class="comment"> * are only done if enabled by the configuration in usbconfig.h.</span>
<a name="l00185"></a>00185 <span class="comment"> */</span>
<a name="l00186"></a>00186 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="keywordtype">void</span>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8c.html#d3eef923d7e69592f8b3aa3bf983bb92">usbSetInterrupt</a>(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len);
<a name="l00188"></a>00188 <span class="comment">/* This function sets the message which will be sent during the next interrupt</span>
<a name="l00189"></a>00189 <span class="comment"> * IN transfer. The message is copied to an internal buffer and must not exceed</span>
<a name="l00190"></a>00190 <span class="comment"> * a length of 8 bytes. The message may be 0 bytes long just to indicate the</span>
<a name="l00191"></a>00191 <span class="comment"> * interrupt status to the host.</span>
<a name="l00192"></a>00192 <span class="comment"> * If you need to transfer more bytes, use a control read after the interrupt.</span>
<a name="l00193"></a>00193 <span class="comment"> */</span>
<a name="l00194"></a>00194 <span class="keyword">extern</span> <span class="keyword">volatile</span> <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2cbb84f982ea77dfbb738af3a027591">schar</a> <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#2e90de9a02954cab2f72d0f509bc4714">usbTxLen1</a>;
<a name="l00195"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1f6b221fb650a7575d4937e37956181d">00195</a> <span class="preprocessor">#define usbInterruptIsReady()   (usbTxLen1 == -1)</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="comment">/* This macro indicates whether the last interrupt message has already been</span>
<a name="l00197"></a>00197 <span class="comment"> * sent. If you set a new interrupt message before the old was sent, the</span>
<a name="l00198"></a>00198 <span class="comment"> * message already buffered will be lost.</span>
<a name="l00199"></a>00199 <span class="comment"> */</span>
<a name="l00200"></a>00200 <span class="preprocessor">#endif </span><span class="comment">/* USB_CFG_HAVE_INTRIN_ENDPOINT */</span>
<a name="l00201"></a>00201 <span class="preprocessor">#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="keyword">extern</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="usbdrv_2usbdrv_8h.html#37718d9af25fd62f30b25e057468e39b">usbHidReportDescriptor</a>[];
<a name="l00203"></a>00203 <span class="comment">/* If you implement an HID device, you need to provide a report descriptor.</span>
<a name="l00204"></a>00204 <span class="comment"> * The HID report descriptor syntax is a bit complex. If you understand how</span>
<a name="l00205"></a>00205 <span class="comment"> * report descriptors are constructed, we recommend that you use the HID</span>
<a name="l00206"></a>00206 <span class="comment"> * Descriptor Tool from usb.org, see http://www.usb.org/developers/hidpage/.</span>
<a name="l00207"></a>00207 <span class="comment"> * Otherwise you should probably start with a working example.</span>
<a name="l00208"></a>00208 <span class="comment"> */</span>
<a name="l00209"></a>00209 <span class="preprocessor">#endif  </span><span class="comment">/* USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH */</span>
<a name="l00210"></a>00210 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="keyword">extern</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    <a class="code" href="bootloader__firmware_2main_8c.html#92f69288e90801df366cde5a838a818f">usbFunctionWrite</a>(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len);
<a name="l00212"></a>00212 <span class="comment">/* This function is called by the driver to provide a control transfer's</span>
<a name="l00213"></a>00213 <span class="comment"> * payload data (control-out). It is called in chunks of up to 8 bytes. The</span>
<a name="l00214"></a>00214 <span class="comment"> * total count provided in the current control transfer can be obtained from</span>
<a name="l00215"></a>00215 <span class="comment"> * the 'length' property in the setup data. If an error occurred during</span>
<a name="l00216"></a>00216 <span class="comment"> * processing, return 0xff (== -1). The driver will answer the entire transfer</span>
<a name="l00217"></a>00217 <span class="comment"> * with a STALL token in this case. If you have received the entire payload</span>
<a name="l00218"></a>00218 <span class="comment"> * successfully, return 1. If you expect more data, return 0. If you don't</span>
<a name="l00219"></a>00219 <span class="comment"> * know whether the host will send more data (you should know, the total is</span>
<a name="l00220"></a>00220 <span class="comment"> * provided in the usbFunctionSetup() call!), return 1.</span>
<a name="l00221"></a>00221 <span class="comment"> * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called</span>
<a name="l00222"></a>00222 <span class="comment"> * for the remaining data. You must continue to return 0xff for STALL in these</span>
<a name="l00223"></a>00223 <span class="comment"> * calls.</span>
<a name="l00224"></a>00224 <span class="comment"> * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00225"></a>00225 <span class="comment"> * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..</span>
<a name="l00226"></a>00226 <span class="comment"> */</span>
<a name="l00227"></a>00227 <span class="preprocessor">#endif </span><span class="comment">/* USB_CFG_IMPLEMENT_FN_WRITE */</span>
<a name="l00228"></a>00228 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="keyword">extern</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> usbFunctionRead(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len);
<a name="l00230"></a>00230 <span class="comment">/* This function is called by the driver to ask the application for a control</span>
<a name="l00231"></a>00231 <span class="comment"> * transfer's payload data (control-in). It is called in chunks of up to 8</span>
<a name="l00232"></a>00232 <span class="comment"> * bytes each. You should copy the data to the location given by 'data' and</span>
<a name="l00233"></a>00233 <span class="comment"> * return the actual number of bytes copied. If you return less than requested,</span>
<a name="l00234"></a>00234 <span class="comment"> * the control-in transfer is terminated. If you return 0xff, the driver aborts</span>
<a name="l00235"></a>00235 <span class="comment"> * the transfer with a STALL token.</span>
<a name="l00236"></a>00236 <span class="comment"> * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00237"></a>00237 <span class="comment"> * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..</span>
<a name="l00238"></a>00238 <span class="comment"> */</span>
<a name="l00239"></a>00239 <span class="preprocessor">#endif </span><span class="comment">/* USB_CFG_IMPLEMENT_FN_READ */</span>
<a name="l00240"></a>00240 <span class="preprocessor">#ifdef USB_CFG_PULLUP_IOPORT</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span><span class="preprocessor">#define usbDeviceConnect()      ((USB_PULLUP_DDR |= (1&lt;&lt;USB_CFG_PULLUP_BIT)), \</span>
<a name="l00242"></a>00242 <span class="preprocessor">                                  (USB_PULLUP_OUT |= (1&lt;&lt;USB_CFG_PULLUP_BIT)))</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="comment">/* This macro (intended to look like a function) connects the device to the</span>
<a name="l00244"></a>00244 <span class="comment"> * USB bus. It is only available if you have defined the constants</span>
<a name="l00245"></a>00245 <span class="comment"> * USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT in usbconfig.h.</span>
<a name="l00246"></a>00246 <span class="comment"> */</span>
<a name="l00247"></a>00247 <span class="preprocessor">#define usbDeviceDisconnect()   (USB_PULLUP_OUT &amp;= ~(1&lt;&lt;USB_CFG_PULLUP_BIT))</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span><span class="comment">/* This macro (intended to look like a function) disconnects the device from</span>
<a name="l00249"></a>00249 <span class="comment"> * the USB bus. It is only available if you have defined the constants</span>
<a name="l00250"></a>00250 <span class="comment"> * USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT in usbconfig.h.</span>
<a name="l00251"></a>00251 <span class="comment"> */</span>
<a name="l00252"></a>00252 <span class="preprocessor">#endif </span><span class="comment">/* USB_CFG_PULLUP_IOPORT */</span>
<a name="l00253"></a>00253 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <a class="code" href="usbdrv_2usbdrv_8h.html#7111154086ae6bb74946b6c157f3ee83">usbCrc16</a>(<a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> len);
<a name="l00254"></a>00254 <span class="comment">/* This function calculates the binary complement of the data CRC used in</span>
<a name="l00255"></a>00255 <span class="comment"> * USB data packets. The value is used to build raw transmit packets.</span>
<a name="l00256"></a>00256 <span class="comment"> * You may want to use this function for data checksums or to verify received</span>
<a name="l00257"></a>00257 <span class="comment"> * data.</span>
<a name="l00258"></a>00258 <span class="comment"> */</span>
<a name="l00259"></a>00259 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <a class="code" href="usbdrv_2usbdrv_8h.html#96a513e4c0943ba6bd42aa1289874340">usbCrc16Append</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> len);
<a name="l00260"></a>00260 <span class="comment">/* This function is equivalent to usbCrc16() above, except that it appends</span>
<a name="l00261"></a>00261 <span class="comment"> * the 2 bytes CRC (lowbyte first) in the 'data' buffer after reading 'len'</span>
<a name="l00262"></a>00262 <span class="comment"> * bytes.</span>
<a name="l00263"></a>00263 <span class="comment"> */</span>
<a name="l00264"></a>00264 <span class="keyword">extern</span> <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>    <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#a43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a>;
<a name="l00265"></a>00265 <span class="comment">/* This value contains the current configuration set by the host. The driver</span>
<a name="l00266"></a>00266 <span class="comment"> * allows setting and querying of this variable with the USB SET_CONFIGURATION</span>
<a name="l00267"></a>00267 <span class="comment"> * and GET_CONFIGURATION requests, but does not use it otherwise.</span>
<a name="l00268"></a>00268 <span class="comment"> * You may want to reflect the "configured" status with a LED on the device or</span>
<a name="l00269"></a>00269 <span class="comment"> * switch on high power parts of the circuit only if the device is configured.</span>
<a name="l00270"></a>00270 <span class="comment"> */</span>
<a name="l00271"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#d94ebd3045d80d1e2ab32c22be4ff96e">00271</a> <span class="preprocessor">#define USB_STRING_DESCRIPTOR_HEADER(stringLength) ((2*(stringLength)+2) | (3&lt;&lt;8))</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span><span class="comment">/* This macro builds a descriptor header for a string descriptor given the</span>
<a name="l00273"></a>00273 <span class="comment"> * string's length. See usbdrv.c for an example how to use it.</span>
<a name="l00274"></a>00274 <span class="comment"> */</span>
<a name="l00275"></a>00275 <span class="preprocessor">#if USB_CFG_SERIAL_NUMBER_LENGTH</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span><span class="keyword">extern</span> <a class="code" href="main_8c.html#4bc2493b9488cbfb5bf35651b8f5ccee">PROGMEM</a> <span class="keywordtype">int</span>  usbCfgSerialNumberStringDescriptor[];
<a name="l00277"></a>00277 <span class="comment">/* This array of unicode characters (prefixed by a string descriptor header as</span>
<a name="l00278"></a>00278 <span class="comment"> * explained above) represents the serial number of the device.</span>
<a name="l00279"></a>00279 <span class="comment"> */</span>
<a name="l00280"></a>00280 <span class="preprocessor">#endif</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span>
<a name="l00282"></a>00282 <span class="preprocessor">#endif  </span><span class="comment">/* __ASSEMBLER__ */</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00285"></a>00285 <span class="comment">/* ------------------------- Constant definitions -------------------------- */</span>
<a name="l00286"></a>00286 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="preprocessor">#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH &amp;&amp; (!defined USB_CFG_VENDOR_ID || !defined USB_CFG_DEVICE_ID)</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span><span class="preprocessor">#error "You MUST NOT use obdev's shared VID/PID with HID class devices!"</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span><span class="comment">/* The shared VID/PID must be used in conjunction with libusb (see license for</span>
<a name="l00291"></a>00291 <span class="comment"> * the IDs). This contradicts HID usage (at least on Windows).</span>
<a name="l00292"></a>00292 <span class="comment"> */</span>
<a name="l00293"></a>00293 <span class="preprocessor">#endif</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>
<a name="l00295"></a>00295 <span class="comment">/* make sure we have a VID and PID defined, byte order is lowbyte, highbyte */</span>
<a name="l00296"></a>00296 <span class="preprocessor">#ifndef USB_CFG_VENDOR_ID</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">#   define  USB_CFG_VENDOR_ID   0xc0, 0x16  </span><span class="comment">/* 5824 in dec, stands for VOTI */</span>
<a name="l00298"></a>00298 <span class="preprocessor">#endif</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>
<a name="l00300"></a>00300 <span class="preprocessor">#ifndef USB_CFG_DEVICE_ID</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span><span class="preprocessor">#   define  USB_CFG_DEVICE_ID   0xdc, 0x05  </span><span class="comment">/* 1500 in dec, obdev's free PID */</span>
<a name="l00302"></a>00302 <span class="preprocessor">#endif</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>
<a name="l00304"></a>00304 <span class="preprocessor">#ifndef USB_BUFFER_SECTION</span>
<a name="l00305"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#52a8394f6e172b45975aa2ffda16acca">00305</a> <span class="preprocessor"></span><span class="preprocessor">#   define  USB_BUFFER_SECTION  ".bss"      </span><span class="comment">/* if user has not selected a named section */</span>
<a name="l00306"></a>00306 <span class="preprocessor">#endif</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a>00308 <span class="comment">/* I/O definitions for assembler module */</span>
<a name="l00309"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#d95fd90d841998e6b54cb99c49ee1247">00309</a> <span class="preprocessor">#define USBOUT          USB_CFG_IOPORT          </span><span class="comment">/* output port for USB bits */</span>
<a name="l00310"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#9ccc1a2e3438323da07a7a784a0884c1">00310</a> <span class="preprocessor">#define USB_PULLUP_OUT  USB_CFG_PULLUP_IOPORT</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span><span class="preprocessor">#ifdef __ASSEMBLER__</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span><span class="comment">/* the following two lines must start in column 0 for IAR assembler */</span>
<a name="l00313"></a>00313 <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#85296740a603c928460d39ef9be869a4">USBIN</a> = (<a class="code" href="bootloader__firmware_2usbconfig_8h.html#3ae6cdc1982572cbd12abd5ccc6b6b62">USB_CFG_IOPORT</a> - 2)                <span class="comment">/* input port for USB bits */</span>
<a name="l00314"></a>00314 <a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3ffc8a49ee40206cfce717574a1ccfea">USBDDR</a> = (<a class="code" href="bootloader__firmware_2usbconfig_8h.html#3ae6cdc1982572cbd12abd5ccc6b6b62">USB_CFG_IOPORT</a> - 1)               <span class="comment">/* data direction for USB bits */</span>
<a name="l00315"></a>00315 <span class="preprocessor">#else</span>
<a name="l00316"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#85296740a603c928460d39ef9be869a4">00316</a> <span class="preprocessor"></span><span class="preprocessor">#define USBIN           (*(&amp;USB_CFG_IOPORT - 2))    </span><span class="comment">/* input port for USB bits */</span>
<a name="l00317"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3ffc8a49ee40206cfce717574a1ccfea">00317</a> <span class="preprocessor">#define USBDDR          (*(&amp;USB_CFG_IOPORT - 1))    </span><span class="comment">/* data direction for USB bits */</span>
<a name="l00318"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#640f2f1d7da9563b9ba418128d539df9">00318</a> <span class="preprocessor">#define USB_PULLUP_DDR  (*(&amp;USB_CFG_PULLUP_IOPORT - 1))</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00320"></a>00320 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_DMINUS_BIT != 0</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span><span class="preprocessor">#   error "USB_CFG_DMINUS_BIT MUST be 0!"</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00323"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#d84a1c137f273772bcba266e0a671d33">00323</a> <span class="preprocessor"></span><span class="preprocessor">#define USBMINUS    0       </span><span class="comment">/* D- MUST be on bit 0 */</span>
<a name="l00324"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#c25f08289ea025246d9682f4ea84ff17">00324</a> <span class="preprocessor">#define USBIDLE     0x01    </span><span class="comment">/* value representing J state */</span>
<a name="l00325"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#0140266b6db5af6ba9167f04a91ca076">00325</a> <span class="preprocessor">#define USBMASK     ((1&lt;&lt;USB_CFG_DPLUS_BIT) | 1)    </span><span class="comment">/* mask for USB I/O bits */</span>
<a name="l00326"></a>00326 
<a name="l00327"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">00327</a> <span class="preprocessor">#define USB_BUFSIZE     11  </span><span class="comment">/* PID, 8 bytes data, 2 bytes CRC */</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="comment">/* Try to find registers and bits responsible for ext interrupt 0 */</span>
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 <span class="preprocessor">#if defined EICRA</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_CFG    EICRA</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00334"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#34cb3bb685c3a6f9c8a63f3a948799b6">00334</a> <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_CFG    MCUCR</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00336"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ab47b4721030fcf7b773ab33f8e0f1c9">00336</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_INTR_CFG_SET    ((1 &lt;&lt; ISC00) | (1 &lt;&lt; ISC01))   </span><span class="comment">/* cfg for rising edge */</span>
<a name="l00337"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#aaa3f824f11c2a5e75acb3841063120d">00337</a> <span class="preprocessor">#define USB_INTR_CFG_CLR    0   </span><span class="comment">/* no bits to clear */</span>
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="preprocessor">#if defined GIMSK</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_ENABLE     GIMSK</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span><span class="preprocessor">#elif defined EIMSK</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_ENABLE     EIMSK</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00344"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#0259fea2ff25be5c0cd58cce07526f84">00344</a> <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_ENABLE     GICR</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00346"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3d028bbfd2e3e723bba54a4ac8fd584c">00346</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_INTR_ENABLE_BIT     INT0</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span>
<a name="l00348"></a>00348 <span class="preprocessor">#if defined EIFR</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_PENDING    EIFR</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00351"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#7011ecaa1385467e7f81909c356a1266">00351</a> <span class="preprocessor"></span><span class="preprocessor">#   define  USB_INTR_PENDING    GIFR</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00353"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#bdde2e43a66667f867e3b9ad89a0a31a">00353</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_INTR_PENDING_BIT    INTF0</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>
<a name="l00355"></a>00355 <span class="comment">/*</span>
<a name="l00356"></a>00356 <span class="comment">The defines above don't work for the following chips</span>
<a name="l00357"></a>00357 <span class="comment">at90c8534: no ISC0?, no PORTB, can't find a data sheet</span>
<a name="l00358"></a>00358 <span class="comment">at86rf401: no PORTB, no MCUCR etc, low clock rate</span>
<a name="l00359"></a>00359 <span class="comment">atmega103: no ISC0? (maybe omission in header, can't find data sheet)</span>
<a name="l00360"></a>00360 <span class="comment">atmega603: not defined in avr-libc</span>
<a name="l00361"></a>00361 <span class="comment">at43usb320, at43usb355, at76c711: have USB anyway</span>
<a name="l00362"></a>00362 <span class="comment">at94k: is different...</span>
<a name="l00363"></a>00363 <span class="comment"></span>
<a name="l00364"></a>00364 <span class="comment">at90s1200, attiny11, attiny12, attiny15, attiny28: these have no RAM</span>
<a name="l00365"></a>00365 <span class="comment">*/</span>
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00368"></a>00368 <span class="comment">/* ----------------- USB Specification Constants and Types ----------------- */</span>
<a name="l00369"></a>00369 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="comment">/* USB Token values */</span>
<a name="l00372"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#3e2083acfa1300227dce323ca04db880">00372</a> <span class="preprocessor">#define USBPID_SETUP    0x2d</span>
<a name="l00373"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#9936cc61bf15c8005def560c71a49498">00373</a> <span class="preprocessor"></span><span class="preprocessor">#define USBPID_OUT      0xe1</span>
<a name="l00374"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#52af2ebd3640f70b8a5200aea73b6eab">00374</a> <span class="preprocessor"></span><span class="preprocessor">#define USBPID_IN       0x69</span>
<a name="l00375"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ddf02692d5a80756e8edfa12f1fb50c6">00375</a> <span class="preprocessor"></span><span class="preprocessor">#define USBPID_DATA0    0xc3</span>
<a name="l00376"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#62e5930e01b6235dd17be080135f1546">00376</a> <span class="preprocessor"></span><span class="preprocessor">#define USBPID_DATA1    0x4b</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span>
<a name="l00378"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#7f9994b8bc3a4864604aa8041ed90faf">00378</a> <span class="preprocessor">#define USBPID_ACK      0xd2</span>
<a name="l00379"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">00379</a> <span class="preprocessor"></span><span class="preprocessor">#define USBPID_NAK      0x5a</span>
<a name="l00380"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1a3759da5a10e0fb525fbf619b3bdb53">00380</a> <span class="preprocessor"></span><span class="preprocessor">#define USBPID_STALL    0x1e</span>
<a name="l00381"></a>00381 <span class="preprocessor"></span>
<a name="l00382"></a>00382 <span class="preprocessor">#ifndef __ASSEMBLER__</span>
<a name="l00383"></a><a class="code" href="unionusbWord.html">00383</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">union </span><a class="code" href="unionusbWord.html">usbWord</a>{
<a name="l00384"></a><a class="code" href="unionusbWord.html#5c18356318175be1ad83c8acab90bf66">00384</a>     <span class="keywordtype">unsigned</span>    <a class="code" href="unionusbWord.html#5c18356318175be1ad83c8acab90bf66">word</a>;
<a name="l00385"></a><a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">00385</a>     <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="unionusbWord.html#0497f26dcfc6fb20080f21103e6696dc">bytes</a>[2];
<a name="l00386"></a>00386 }<a class="code" href="unionusbWord.html">usbWord_t</a>;
<a name="l00387"></a>00387 
<a name="l00388"></a><a class="code" href="structusbRequest.html">00388</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structusbRequest.html">usbRequest</a>{
<a name="l00389"></a><a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">00389</a>     <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="structusbRequest.html#05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a>;
<a name="l00390"></a><a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">00390</a>     <a class="code" href="bootloader__firmware_2usbdrv_2oddebug_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="structusbRequest.html#34c18b1dd0af60774cac48b176220c2c">bRequest</a>;
<a name="l00391"></a><a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">00391</a>     <a class="code" href="unionusbWord.html">usbWord_t</a>   <a class="code" href="structusbRequest.html#b3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>;
<a name="l00392"></a><a class="code" href="structusbRequest.html#efa059246bf079d5b42af148a2ad6a95">00392</a>     <a class="code" href="unionusbWord.html">usbWord_t</a>   <a class="code" href="structusbRequest.html#efa059246bf079d5b42af148a2ad6a95">wIndex</a>;
<a name="l00393"></a><a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">00393</a>     <a class="code" href="unionusbWord.html">usbWord_t</a>   <a class="code" href="structusbRequest.html#770437881c2e37d1384982fe26d87e7f">wLength</a>;
<a name="l00394"></a>00394 }<a class="code" href="structusbRequest.html">usbRequest_t</a>;
<a name="l00395"></a>00395 <span class="comment">/* This structure matches the 8 byte setup request */</span>
<a name="l00396"></a>00396 <span class="preprocessor">#endif</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span>
<a name="l00398"></a>00398 <span class="comment">/* bmRequestType field in USB setup:</span>
<a name="l00399"></a>00399 <span class="comment"> * d t t r r r r r, where</span>
<a name="l00400"></a>00400 <span class="comment"> * d ..... direction: 0=host-&gt;device, 1=device-&gt;host</span>
<a name="l00401"></a>00401 <span class="comment"> * t ..... type: 0=standard, 1=class, 2=vendor, 3=reserved</span>
<a name="l00402"></a>00402 <span class="comment"> * r ..... recipient: 0=device, 1=interface, 2=endpoint, 3=other</span>
<a name="l00403"></a>00403 <span class="comment"> */</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">/* USB setup recipient values */</span>
<a name="l00406"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#5ae0c6cdfa26c87300c3a01aa2b0c7e2">00406</a> <span class="preprocessor">#define USBRQ_RCPT_MASK         0x1f</span>
<a name="l00407"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#eb145a6378e20ee3aedaa81fffd08d5d">00407</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_RCPT_DEVICE       0</span>
<a name="l00408"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#fc17e89d6963cc359d8f7de2f7a1e39d">00408</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_RCPT_INTERFACE    1</span>
<a name="l00409"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#6c25d62097af881d30af436c07773a26">00409</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_RCPT_ENDPOINT     2</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span>
<a name="l00411"></a>00411 <span class="comment">/* USB request type values */</span>
<a name="l00412"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ef7b9c4cc4266e79c677fd42e2abb40e">00412</a> <span class="preprocessor">#define USBRQ_TYPE_MASK         0x60</span>
<a name="l00413"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#a2eaf9447ddfc30442e8b6bd13cfd969">00413</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_TYPE_STANDARD     (0&lt;&lt;5)</span>
<a name="l00414"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#5c5f92099964ea08cc8cf0bccb8ca4ed">00414</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_TYPE_CLASS        (1&lt;&lt;5)</span>
<a name="l00415"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#c4992ceee7d8bd052dedb4ac63599cdc">00415</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_TYPE_VENDOR       (2&lt;&lt;5)</span>
<a name="l00416"></a>00416 <span class="preprocessor"></span>
<a name="l00417"></a>00417 <span class="comment">/* USB direction values: */</span>
<a name="l00418"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#7754f61bfa2e16800aa396896092f50a">00418</a> <span class="preprocessor">#define USBRQ_DIR_MASK              0x80</span>
<a name="l00419"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#a187b3efe1a0ef577e6f695a47608bef">00419</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_DIR_HOST_TO_DEVICE    (0&lt;&lt;7)</span>
<a name="l00420"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#04a0c4970f7371115638586bc8a14325">00420</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_DIR_DEVICE_TO_HOST    (1&lt;&lt;7)</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>
<a name="l00422"></a>00422 <span class="comment">/* USB Standard Requests */</span>
<a name="l00423"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#523252bd739d1b14018ec34e49466d72">00423</a> <span class="preprocessor">#define USBRQ_GET_STATUS        0</span>
<a name="l00424"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#82766d6fb4294e1cb5f7cb2086e81715">00424</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_CLEAR_FEATURE     1</span>
<a name="l00425"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1802461b0f91708022a66f407fadd1f1">00425</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_SET_FEATURE       3</span>
<a name="l00426"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#6837bf1e17c56a25b97db0be68b03519">00426</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_SET_ADDRESS       5</span>
<a name="l00427"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#225b041572762941a96694d5498e853e">00427</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_GET_DESCRIPTOR    6</span>
<a name="l00428"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#2fb2a12d1a7d37bce6bcf535f48ade9e">00428</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_SET_DESCRIPTOR    7</span>
<a name="l00429"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#16d2228bcfa8944c18a39df43016cea5">00429</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_GET_CONFIGURATION 8</span>
<a name="l00430"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#fc6adbbfd47da950ccf50277a41bfe58">00430</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_SET_CONFIGURATION 9</span>
<a name="l00431"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#44a94b5f45d9ffb957b9590eea8a73a4">00431</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_GET_INTERFACE     10</span>
<a name="l00432"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#904cc1bbdd859501d590ce47099a49ec">00432</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_SET_INTERFACE     11</span>
<a name="l00433"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#c4b47c9502650f6a74714f852825746c">00433</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_SYNCH_FRAME       12</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>
<a name="l00435"></a>00435 <span class="comment">/* USB descriptor constants */</span>
<a name="l00436"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#5b76593f7b6295a4a599aba4476ec258">00436</a> <span class="preprocessor">#define USBDESCR_DEVICE         1</span>
<a name="l00437"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#6ff1081ad7212a0c7009ef5b79f3669f">00437</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_CONFIG         2</span>
<a name="l00438"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#abd48b46ba597bd32ce5c64a7aad23c4">00438</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_STRING         3</span>
<a name="l00439"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#1ce81e6fb124d8747018b4343faa65ba">00439</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_INTERFACE      4</span>
<a name="l00440"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#b2c475dbe374ed8bc514893fb97a6083">00440</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_ENDPOINT       5</span>
<a name="l00441"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#de4fe1fba6aca94a379fdbacbbcc6800">00441</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_HID            0x21</span>
<a name="l00442"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f2ef6d7e2fe214a3d3a14f5419550bb0">00442</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_HID_REPORT     0x22</span>
<a name="l00443"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#046aff487dd2c149d8df8ebf01a1f05d">00443</a> <span class="preprocessor"></span><span class="preprocessor">#define USBDESCR_HID_PHYS       0x23</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span>
<a name="l00445"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#9731bc516bc018f3b0f50a455d5a5681">00445</a> <span class="preprocessor">#define USBATTR_BUSPOWER        0x80</span>
<a name="l00446"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#fa0dd9c06af4b033461ba3c755ca90bb">00446</a> <span class="preprocessor"></span><span class="preprocessor">#define USBATTR_SELFPOWER       0x40</span>
<a name="l00447"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#4f6ede34dea10d728413690ac694a74b">00447</a> <span class="preprocessor"></span><span class="preprocessor">#define USBATTR_REMOTEWAKE      0x20</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449 <span class="comment">/* USB HID Requests */</span>
<a name="l00450"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#b0c796905d6a7d0bfc605f8c3e252437">00450</a> <span class="preprocessor">#define USBRQ_HID_GET_REPORT    0x01</span>
<a name="l00451"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#ebf7c3254b56413d7679b89bb99e144c">00451</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_HID_GET_IDLE      0x02</span>
<a name="l00452"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#c70990c038444434de16c30399e92640">00452</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_HID_GET_PROTOCOL  0x03</span>
<a name="l00453"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#f0b62de651c6d73af4cfb1cee123c312">00453</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_HID_SET_REPORT    0x09</span>
<a name="l00454"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#0d7b2ebb28c23a8bd2fb4a630b85ad71">00454</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_HID_SET_IDLE      0x0a</span>
<a name="l00455"></a><a class="code" href="bootloader__firmware_2usbdrv_2usbdrv_8h.html#831d5e0db9e559706e54acc2e7b5278c">00455</a> <span class="preprocessor"></span><span class="preprocessor">#define USBRQ_HID_SET_PROTOCOL  0x0b</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span>
<a name="l00457"></a>00457 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="preprocessor">#endif </span><span class="comment">/* __usbdrv_h_included__ */</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 30 15:43:33 2009 for USB IR HID Device by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
