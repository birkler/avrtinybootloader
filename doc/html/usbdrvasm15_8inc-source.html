<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>USB IR HID Device: usbdrv/usbdrvasm15.inc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>usbdrv/usbdrvasm15.inc</h1><a href="usbdrvasm15_8inc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Name: usbdrvasm15.inc</span>
<a name="l00002"></a>00002 <span class="comment"> * Project: AVR USB driver</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: contributed by V. Bosch</span>
<a name="l00004"></a>00004 <span class="comment"> * Creation Date: 2007-08-06</span>
<a name="l00005"></a>00005 <span class="comment"> * Tabsize: 4</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH</span>
<a name="l00007"></a>00007 <span class="comment"> * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)</span>
<a name="l00008"></a>00008 <span class="comment"> * Revision: $Id$</span>
<a name="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">/* Do not link this file! Link usbdrvasm.S instead, which includes the</span>
<a name="l00012"></a>00012 <span class="comment"> * appropriate implementation!</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="comment">/*</span>
<a name="l00016"></a>00016 <span class="comment">General Description:</span>
<a name="l00017"></a>00017 <span class="comment">This file is the 15 MHz version of the asssembler part of the USB driver. It</span>
<a name="l00018"></a>00018 <span class="comment">requires a 15 MHz crystal (not a ceramic resonator and not a calibrated RC</span>
<a name="l00019"></a>00019 <span class="comment">oscillator).</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">See usbdrv.h for a description of the entire driver.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">Since almost all of this code is timing critical, don't change unless you</span>
<a name="l00024"></a>00024 <span class="comment">really know what you are doing! Many parts require not only a maximum number</span>
<a name="l00025"></a>00025 <span class="comment">of CPU cycles, but even an exact number of cycles!</span>
<a name="l00026"></a>00026 <span class="comment">*/</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 ;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
<a name="l00029"></a>00029 ;nominal frequency: 15 MHz -&gt; 10.0 cycles per bit, 80.0 cycles per byte
<a name="l00030"></a>00030 ; Numbers in brackets are clocks counted from center of last sync bit
<a name="l00031"></a>00031 ; when instruction starts
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 ;----------------------------------------------------------------------------
<a name="l00034"></a>00034 ; order of registers pushed: 
<a name="l00035"></a>00035 ; YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
<a name="l00036"></a>00036 ;----------------------------------------------------------------------------
<a name="l00037"></a>00037 USB_INTR_VECTOR:              
<a name="l00038"></a>00038     push    YL                   ;2   push only what is necessary to sync with edge ASAP
<a name="l00039"></a>00039     in      YL, SREG             ;1 
<a name="l00040"></a>00040     push    YL                   ;2 
<a name="l00041"></a>00041 ;----------------------------------------------------------------------------
<a name="l00042"></a>00042 ; Synchronize with sync pattern:
<a name="l00043"></a>00043 ;
<a name="l00044"></a>00044 ;   sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
<a name="l00045"></a>00045 ;   sync up with J to K edge during sync pattern -- use fastest possible loops
<a name="l00046"></a>00046 ;   first part has no timeout because it waits for IDLE or SE1 (== disconnected)
<a name="l00047"></a>00047 ;-------------------------------------------------------------------------------
<a name="l00048"></a>00048 waitForJ:      ;- 
<a name="l00049"></a>00049     sbis    <a class="code" href="usbdrv_8h.html#85296740a603c928460d39ef9be869a4">USBIN</a>, <a class="code" href="usbdrv_8h.html#d84a1c137f273772bcba266e0a671d33">USBMINUS</a>      ;1 &lt;-- sample: wait for D- == 1
<a name="l00050"></a>00050     rjmp    waitForJ     ;2 
<a name="l00051"></a>00051 ;-------------------------------------------------------------------------------
<a name="l00052"></a>00052 ; The following code results in a sampling window of &lt; 1/4 bit 
<a name="l00053"></a>00053 ; which meets the spec.
<a name="l00054"></a>00054 ;-------------------------------------------------------------------------------
<a name="l00055"></a>00055 waitForK:      ;- 
<a name="l00056"></a>00056     sbis    USBIN, USBMINUS      ;1 [00] &lt;-- sample
<a name="l00057"></a>00057     rjmp    foundK               ;2 [01]
<a name="l00058"></a>00058     sbis    USBIN, USBMINUS  ;   &lt;-- sample
<a name="l00059"></a>00059     rjmp    foundK
<a name="l00060"></a>00060     sbis    USBIN, USBMINUS  ;   &lt;-- sample
<a name="l00061"></a>00061     rjmp    foundK
<a name="l00062"></a>00062     sbis    USBIN, USBMINUS  ;   &lt;-- sample
<a name="l00063"></a>00063     rjmp    foundK
<a name="l00064"></a>00064     sbis    USBIN, USBMINUS  ;   &lt;-- sample
<a name="l00065"></a>00065     rjmp    foundK
<a name="l00066"></a>00066     sbis    USBIN, USBMINUS  ;   &lt;-- sample
<a name="l00067"></a>00067     rjmp    foundK
<a name="l00068"></a>00068 <span class="preprocessor">#if USB_COUNT_SOF</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>    lds     YL, usbSofCount
<a name="l00070"></a>00070     inc     YL
<a name="l00071"></a>00071     sts     usbSofCount, YL
<a name="l00072"></a>00072 <span class="preprocessor">#endif  </span><span class="comment">/* USB_COUNT_SOF */</span>
<a name="l00073"></a>00073     rjmp    sofError
<a name="l00074"></a>00074 ;------------------------------------------------------------------------------
<a name="l00075"></a>00075 ; {3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for 
<a name="l00076"></a>00076 ; center sampling] 
<a name="l00077"></a>00077 ;   we have 1 bit time <span class="keywordflow">for</span> setup purposes, then sample again. 
<a name="l00078"></a>00078 ; Numbers in brackets are cycles from center of first sync (<span class="keywordtype">double</span> K) 
<a name="l00079"></a>00079 ; bit after the instruction
<a name="l00080"></a>00080 ;------------------------------------------------------------------------------
<a name="l00081"></a>00081 foundK:                          ;- [02]
<a name="l00082"></a>00082     lds     YL, <a class="code" href="usbdrv_8c.html#6b0f7b83997deee705eb56462e3f1fce">usbInputBufOffset</a>;2 [03+04] tx loop
<a name="l00083"></a>00083     push    YH                   ;2 [05+06]
<a name="l00084"></a>00084     clr     YH                   ;1 [07]
<a name="l00085"></a>00085     subi    YL, lo8(-(<a class="code" href="usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>)) ;1 [08]  [rx loop init]
<a name="l00086"></a>00086     sbci    YH, hi8(-(<a class="code" href="usbdrv_8c.html#50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>)) ;1 [09]  [rx loop init]
<a name="l00087"></a>00087     push    shift                ;2 [10+11]
<a name="l00088"></a>00088     ser     shift    ;1 [12]
<a name="l00089"></a>00089     sbis    USBIN, USBMINUS      ;1 [-1] [13] &lt;--sample:we want two bits K (sample 1 cycle too early)
<a name="l00090"></a>00090     rjmp    haveTwoBitsK         ;2 [00] [14]
<a name="l00091"></a>00091     pop     shift                ;2    [15+16] undo the push from before
<a name="l00092"></a>00092     pop     YH       ;2    [17+18] undo the push from before
<a name="l00093"></a>00093     rjmp    waitForK             ;2    [19+20] <span class="keyword">this</span> was not the end of sync, retry
<a name="l00094"></a>00094 ; The entire loop from waitForK until rjmp waitForK above must not exceed two
<a name="l00095"></a>00095 ; bit times (= 20 cycles).
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 ;----------------------------------------------------------------------------
<a name="l00098"></a>00098 ; push more registers and initialize values <span class="keywordflow">while</span> we sample the first bits:
<a name="l00099"></a>00099 ;----------------------------------------------------------------------------
<a name="l00100"></a>00100 haveTwoBitsK:     ;- [01]
<a name="l00101"></a>00101     push    x1                ;2 [02+03]
<a name="l00102"></a>00102     push    x2                ;2 [04+05]
<a name="l00103"></a>00103     push    x3                ;2 [06+07]
<a name="l00104"></a>00104     push    bitcnt              ;2 [08+09]  
<a name="l00105"></a>00105     in      x1, USBIN         ;1 [00] [10] &lt;-- sample bit 0
<a name="l00106"></a>00106     bst     x1, USBMINUS      ;1 [01]
<a name="l00107"></a>00107     bld     shift, 0          ;1 [02]
<a name="l00108"></a>00108     push    cnt               ;2 [03+04]
<a name="l00109"></a>00109     ldi     cnt, <a class="code" href="usbdrv_8h.html#1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>  ;1 [05] 
<a name="l00110"></a>00110     push    x4                ;2 [06+07] tx loop
<a name="l00111"></a>00111     rjmp    rxLoop            ;2 [08]
<a name="l00112"></a>00112 ;----------------------------------------------------------------------------
<a name="l00113"></a>00113 ; Receiver loop (numbers in brackets are cycles within byte after instr)
<a name="l00114"></a>00114 ;----------------------------------------------------------------------------
<a name="l00115"></a>00115 unstuff0:                 ;- [07] (branch taken)
<a name="l00116"></a>00116     andi    x3, ~0x01     ;1 [08]
<a name="l00117"></a>00117     mov     x1, x2        ;1 [09] x2 contains last sampled (stuffed) bit
<a name="l00118"></a>00118     in      x2, USBIN     ;1 [00] [10] &lt;-- sample bit 1 again
<a name="l00119"></a>00119     andi    x2, <a class="code" href="usbdrv_8h.html#0140266b6db5af6ba9167f04a91ca076">USBMASK</a>   ;1 [01]
<a name="l00120"></a>00120     breq    se0Hop          ;1 [02] SE0 check for bit 1 
<a name="l00121"></a>00121     ori     shift, 0x01   ;1 [03] 0b00000001
<a name="l00122"></a>00122     nop       ;1 [04]
<a name="l00123"></a>00123     rjmp    didUnstuff0   ;2 [05]
<a name="l00124"></a>00124 ;-----------------------------------------------------
<a name="l00125"></a>00125 unstuff1:                 ;- [05] (branch taken)
<a name="l00126"></a>00126     mov     x2, x1        ;1 [06] x1 contains last sampled (stuffed) bit
<a name="l00127"></a>00127     andi    x3, ~0x02     ;1 [07]
<a name="l00128"></a>00128     ori     shift, 0x02   ;1 [08] 0b00000010
<a name="l00129"></a>00129     nop                   ;1 [09]
<a name="l00130"></a>00130     in      x1, USBIN     ;1 [00] [10] &lt;-- sample bit 2 again
<a name="l00131"></a>00131     andi    x1, USBMASK   ;1 [01]
<a name="l00132"></a>00132     breq    se0Hop          ;1 [02] SE0 check for bit 2 
<a name="l00133"></a>00133     rjmp    didUnstuff1   ;2 [03]
<a name="l00134"></a>00134 ;-----------------------------------------------------
<a name="l00135"></a>00135 unstuff2:                 ;- [05] (branch taken)
<a name="l00136"></a>00136     andi    x3, ~0x04     ;1 [06]
<a name="l00137"></a>00137     ori     shift, 0x04   ;1 [07] 0b00000100
<a name="l00138"></a>00138     mov     x1, x2        ;1 [08] x2 contains last sampled (stuffed) bit
<a name="l00139"></a>00139     nop                   ;1 [09]
<a name="l00140"></a>00140     in      x2, USBIN     ;1 [00] [10] &lt;-- sample bit 3
<a name="l00141"></a>00141     andi    x2, USBMASK   ;1 [01]
<a name="l00142"></a>00142     breq    se0Hop          ;1 [02] SE0 check for bit 3 
<a name="l00143"></a>00143     rjmp    didUnstuff2   ;2 [03]
<a name="l00144"></a>00144 ;-----------------------------------------------------
<a name="l00145"></a>00145 unstuff3:                 ;- [00] [10]  (branch taken)
<a name="l00146"></a>00146     in      x2, USBIN     ;1 [01] [11] &lt;-- sample stuffed bit 3 one cycle too late
<a name="l00147"></a>00147     andi    x2, USBMASK   ;1 [02]
<a name="l00148"></a>00148     breq    se0Hop          ;1 [03] SE0 check for stuffed bit 3 
<a name="l00149"></a>00149     andi    x3, ~0x08     ;1 [04]
<a name="l00150"></a>00150     ori     shift, 0x08   ;1 [05] 0b00001000
<a name="l00151"></a>00151     rjmp    didUnstuff3   ;2 [06]
<a name="l00152"></a>00152 ;----------------------------------------------------------------------------
<a name="l00153"></a>00153 ; extra jobs done during bit interval:
<a name="l00154"></a>00154 ;
<a name="l00155"></a>00155 ; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs], 
<a name="l00156"></a>00156 ;     overflow check, jump to the head of rxLoop
<a name="l00157"></a>00157 ; bit 1:    SE0 check
<a name="l00158"></a>00158 ; bit 2:    SE0 check, recovery from delay [bit 0 tasks took too <span class="keywordtype">long</span>]
<a name="l00159"></a>00159 ; bit 3:    SE0 check, recovery from delay [bit 0 tasks took too <span class="keywordtype">long</span>]
<a name="l00160"></a>00160 ; bit 4:    SE0 check, none
<a name="l00161"></a>00161 ; bit 5:    SE0 check, none
<a name="l00162"></a>00162 ; bit 6:    SE0 check, none
<a name="l00163"></a>00163 ; bit 7:    SE0 check, reconstruct: x3 is 0 at bit locations we changed, 1 at others
<a name="l00164"></a>00164 ;----------------------------------------------------------------------------
<a name="l00165"></a>00165 rxLoop:       ;- [09]
<a name="l00166"></a>00166     in      x2, USBIN     ;1 [00] [10] &lt;-- sample bit 1 (or possibly bit 0 stuffed)
<a name="l00167"></a>00167     andi    x2, USBMASK   ;1 [01]
<a name="l00168"></a>00168     brne    SkipSe0Hop    ;1 [02]
<a name="l00169"></a>00169 se0Hop:       ;- [02]
<a name="l00170"></a>00170     rjmp    se0           ;2 [03] SE0 check for bit 1 
<a name="l00171"></a>00171 SkipSe0Hop:     ;- [03]
<a name="l00172"></a>00172     ser     x3            ;1 [04]
<a name="l00173"></a>00173     andi    shift, 0xf9   ;1 [05] 0b11111001
<a name="l00174"></a>00174     breq    unstuff0      ;1 [06]
<a name="l00175"></a>00175 didUnstuff0:      ;- [06]
<a name="l00176"></a>00176     eor     x1, x2        ;1 [07]
<a name="l00177"></a>00177     bst     x1, USBMINUS  ;1 [08]
<a name="l00178"></a>00178     bld     shift, 1      ;1 [09] 
<a name="l00179"></a>00179     in      x1, USBIN     ;1 [00] [10] &lt;-- sample bit 2 (or possibly bit 1 stuffed)
<a name="l00180"></a>00180     andi    x1, USBMASK   ;1 [01]
<a name="l00181"></a>00181     breq    se0Hop          ;1 [02] SE0 check for bit 2 
<a name="l00182"></a>00182     andi    shift, 0xf3   ;1 [03] 0b11110011
<a name="l00183"></a>00183     breq    unstuff1      ;1 [04] do remaining work for bit 1
<a name="l00184"></a>00184 didUnstuff1:      ;- [04]
<a name="l00185"></a>00185     eor     x2, x1        ;1 [05]
<a name="l00186"></a>00186     bst     x2, USBMINUS  ;1 [06]
<a name="l00187"></a>00187     bld     shift, 2      ;1 [07]
<a name="l00188"></a>00188     nop2      ;2 [08+09]
<a name="l00189"></a>00189     in      x2, USBIN     ;1 [00] [10] &lt;-- sample bit 3 (or possibly bit 2 stuffed)
<a name="l00190"></a>00190     andi    x2, USBMASK   ;1 [01]
<a name="l00191"></a>00191     breq    se0Hop          ;1 [02] SE0 check for bit 3 
<a name="l00192"></a>00192     andi    shift, 0xe7   ;1 [03] 0b11100111
<a name="l00193"></a>00193     breq    unstuff2      ;1 [04]
<a name="l00194"></a>00194 didUnstuff2:      ;- [04]
<a name="l00195"></a>00195     eor     x1, x2        ;1 [05]
<a name="l00196"></a>00196     bst     x1, USBMINUS  ;1 [06]
<a name="l00197"></a>00197     bld     shift, 3      ;1 [07]
<a name="l00198"></a>00198 didUnstuff3:      ;- [07]
<a name="l00199"></a>00199     andi    shift, 0xcf   ;1 [08] 0b11001111
<a name="l00200"></a>00200     breq    unstuff3      ;1 [09]
<a name="l00201"></a>00201     in      x1, USBIN     ;1 [00] [10] &lt;-- sample bit 4
<a name="l00202"></a>00202     andi    x1, USBMASK   ;1 [01]
<a name="l00203"></a>00203     breq    se0Hop          ;1 [02] SE0 check for bit 4
<a name="l00204"></a>00204     eor     x2, x1        ;1 [03]
<a name="l00205"></a>00205     bst     x2, USBMINUS  ;1 [04]
<a name="l00206"></a>00206     bld     shift, 4      ;1 [05]
<a name="l00207"></a>00207 didUnstuff4:      ;- [05]
<a name="l00208"></a>00208     andi    shift, 0x9f   ;1 [06] 0b10011111
<a name="l00209"></a>00209     breq    unstuff4      ;1 [07]
<a name="l00210"></a>00210     nop2      ;2 [08+09]
<a name="l00211"></a>00211     in      x2, USBIN     ;1 [00] [10] &lt;-- sample bit 5
<a name="l00212"></a>00212     andi    x2, USBMASK   ;1 [01]
<a name="l00213"></a>00213     breq    se0           ;1 [02] SE0 check for bit 5
<a name="l00214"></a>00214     eor     x1, x2        ;1 [03]
<a name="l00215"></a>00215     bst     x1, USBMINUS  ;1 [04]
<a name="l00216"></a>00216     bld     shift, 5      ;1 [05]
<a name="l00217"></a>00217 didUnstuff5:      ;- [05]
<a name="l00218"></a>00218     andi    shift, 0x3f   ;1 [06] 0b00111111
<a name="l00219"></a>00219     breq    unstuff5      ;1 [07]
<a name="l00220"></a>00220     nop2      ;2 [08+09]
<a name="l00221"></a>00221     in      x1, USBIN     ;1 [00] [10] &lt;-- sample bit 6
<a name="l00222"></a>00222     andi    x1, USBMASK   ;1 [01]
<a name="l00223"></a>00223     breq    se0           ;1 [02] SE0 check for bit 6
<a name="l00224"></a>00224     eor     x2, x1        ;1 [03]
<a name="l00225"></a>00225     bst     x2, USBMINUS  ;1 [04]
<a name="l00226"></a>00226     bld     shift, 6      ;1 [05]
<a name="l00227"></a>00227 didUnstuff6:      ;- [05]
<a name="l00228"></a>00228     cpi     shift, 0x02   ;1 [06] 0b00000010
<a name="l00229"></a>00229     brlo    unstuff6      ;1 [07]
<a name="l00230"></a>00230     nop2      ;2 [08+09]
<a name="l00231"></a>00231     in      x2, USBIN     ;1 [00] [10] &lt;-- sample bit 7
<a name="l00232"></a>00232     andi    x2, USBMASK   ;1 [01]
<a name="l00233"></a>00233     breq    se0           ;1 [02] SE0 check for bit 7
<a name="l00234"></a>00234     eor     x1, x2        ;1 [03]
<a name="l00235"></a>00235     bst     x1, USBMINUS  ;1 [04]
<a name="l00236"></a>00236     bld     shift, 7      ;1 [05]
<a name="l00237"></a>00237 didUnstuff7:      ;- [05] 
<a name="l00238"></a>00238     cpi     shift, 0x04   ;1 [06] 0b00000100
<a name="l00239"></a>00239     brlo    unstuff7    ;1 [07]
<a name="l00240"></a>00240     eor     x3, shift     ;1 [08] reconstruct: x3 is 0 at bit locations we changed, 1 at others
<a name="l00241"></a>00241     nop       ;1 [09]
<a name="l00242"></a>00242     in      x1, USBIN     ;1 [00] [10] &lt;-- sample bit 0
<a name="l00243"></a>00243     st      y+, x3        ;2 [01+02] store data
<a name="l00244"></a>00244     eor     x2, x1        ;1 [03]
<a name="l00245"></a>00245     bst     x2, USBMINUS  ;1 [04]
<a name="l00246"></a>00246     bld     shift, 0      ;1 [05]
<a name="l00247"></a>00247     subi    cnt, 1    ;1 [06]
<a name="l00248"></a>00248     brcs    overflow  ;1 [07]
<a name="l00249"></a>00249     rjmp    rxLoop    ;2 [08]
<a name="l00250"></a>00250 ;-----------------------------------------------------
<a name="l00251"></a>00251 unstuff4:                 ;- [08] 
<a name="l00252"></a>00252     andi    x3, ~0x10     ;1 [09]
<a name="l00253"></a>00253     in      x1, USBIN     ;1 [00] [10] &lt;-- sample stuffed bit 4
<a name="l00254"></a>00254     andi    x1, USBMASK   ;1 [01]
<a name="l00255"></a>00255     breq    se0           ;1 [02] SE0 check for stuffed bit 4
<a name="l00256"></a>00256     ori     shift, 0x10   ;1 [03]
<a name="l00257"></a>00257     rjmp    didUnstuff4   ;2 [04]
<a name="l00258"></a>00258 ;-----------------------------------------------------
<a name="l00259"></a>00259 unstuff5:                 ;- [08] 
<a name="l00260"></a>00260     ori     shift, 0x20   ;1 [09]
<a name="l00261"></a>00261     in      x2, USBIN     ;1 [00] [10] &lt;-- sample stuffed bit 5
<a name="l00262"></a>00262     andi    x2, USBMASK   ;1 [01]
<a name="l00263"></a>00263     breq    se0           ;1 [02] SE0 check for stuffed bit 5
<a name="l00264"></a>00264     andi    x3, ~0x20     ;1 [03]
<a name="l00265"></a>00265     rjmp    didUnstuff5   ;2 [04]
<a name="l00266"></a>00266 ;-----------------------------------------------------
<a name="l00267"></a>00267 unstuff6:                 ;- [08] 
<a name="l00268"></a>00268     andi    x3, ~0x40     ;1 [09]
<a name="l00269"></a>00269     in      x1, USBIN     ;1 [00] [10] &lt;-- sample stuffed bit 6
<a name="l00270"></a>00270     andi    x1, USBMASK   ;1 [01]
<a name="l00271"></a>00271     breq    se0           ;1 [02] SE0 check for stuffed bit 6
<a name="l00272"></a>00272     ori     shift, 0x40   ;1 [03]
<a name="l00273"></a>00273     rjmp    didUnstuff6   ;2 [04]
<a name="l00274"></a>00274 ;-----------------------------------------------------
<a name="l00275"></a>00275 unstuff7:     ;- [08]
<a name="l00276"></a>00276     andi    x3, ~0x80     ;1 [09]
<a name="l00277"></a>00277     in      x2, USBIN     ;1 [00] [10] &lt;-- sample stuffed bit 7
<a name="l00278"></a>00278     andi    x2, USBMASK   ;1 [01]
<a name="l00279"></a>00279     breq    se0           ;1 [02] SE0 check for stuffed bit 7
<a name="l00280"></a>00280     ori     shift, 0x80   ;1 [03]
<a name="l00281"></a>00281     rjmp    didUnstuff7   ;2 [04]
<a name="l00282"></a>00282     
<a name="l00283"></a>00283 macro POP_STANDARD ; 16 cycles
<a name="l00284"></a>00284     pop     x4    
<a name="l00285"></a>00285     pop     cnt
<a name="l00286"></a>00286     pop     bitcnt
<a name="l00287"></a>00287     pop     x3
<a name="l00288"></a>00288     pop     x2
<a name="l00289"></a>00289     pop     x1
<a name="l00290"></a>00290     pop     shift
<a name="l00291"></a>00291     pop     YH
<a name="l00292"></a>00292 endm
<a name="l00293"></a>00293 macro POP_RETI     ; 5 cycles
<a name="l00294"></a>00294     pop     YL
<a name="l00295"></a>00295     out     SREG, YL
<a name="l00296"></a>00296     pop     YL
<a name="l00297"></a>00297 endm
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="preprocessor">#include "asmcommon.inc"</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>
<a name="l00301"></a>00301 ;---------------------------------------------------------------------------
<a name="l00302"></a>00302 ; USB spec says:
<a name="l00303"></a>00303 ; idle = J
<a name="l00304"></a>00304 ; J = (D+ = 0), (D- = 1)
<a name="l00305"></a>00305 ; K = (D+ = 1), (D- = 0)
<a name="l00306"></a>00306 ; Spec allows 7.5 bit times from EOP to SOP <span class="keywordflow">for</span> replies
<a name="l00307"></a>00307 ;---------------------------------------------------------------------------
<a name="l00308"></a>00308 bitstuffN:          ;- [04]
<a name="l00309"></a>00309     eor     x1, x4            ;1 [05]
<a name="l00310"></a>00310     clr     x2      ;1 [06]
<a name="l00311"></a>00311     nop       ;1 [07]
<a name="l00312"></a>00312     rjmp    didStuffN         ;1 [08]
<a name="l00313"></a>00313 ;---------------------------------------------------------------------------    
<a name="l00314"></a>00314 bitstuff6:          ;- [04]
<a name="l00315"></a>00315     eor     x1, x4            ;1 [05]
<a name="l00316"></a>00316     clr     x2      ;1 [06]
<a name="l00317"></a>00317     rjmp    didStuff6         ;1 [07]
<a name="l00318"></a>00318 ;---------------------------------------------------------------------------
<a name="l00319"></a>00319 bitstuff7:          ;- [02]
<a name="l00320"></a>00320     eor     x1, x4            ;1 [03]
<a name="l00321"></a>00321     clr     x2      ;1 [06]
<a name="l00322"></a>00322     nop           ;1 [05]
<a name="l00323"></a>00323     rjmp    didStuff7         ;1 [06]
<a name="l00324"></a>00324 ;---------------------------------------------------------------------------
<a name="l00325"></a>00325 sendNakAndReti:     ;- [-19]
<a name="l00326"></a>00326     ldi     x3, <a class="code" href="usbdrv_8h.html#481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>    ;1 [-18]
<a name="l00327"></a>00327     rjmp    sendX3AndReti     ;1 [-17]
<a name="l00328"></a>00328 ;---------------------------------------------------------------------------
<a name="l00329"></a>00329 sendAckAndReti:     ;- [-17]
<a name="l00330"></a>00330     ldi     cnt, <a class="code" href="usbdrv_8h.html#7f9994b8bc3a4864604aa8041ed90faf">USBPID_ACK</a>   ;1 [-16]
<a name="l00331"></a>00331 sendCntAndReti:     ;- [-16]
<a name="l00332"></a>00332     mov     x3, cnt           ;1 [-15]
<a name="l00333"></a>00333 sendX3AndReti:      ;- [-15]
<a name="l00334"></a>00334     ldi     YL, 20            ;1 [-14] x3==r20 address is 20
<a name="l00335"></a>00335     ldi     YH, 0             ;1 [-13]
<a name="l00336"></a>00336     ldi     cnt, 2            ;1 [-12]
<a name="l00337"></a>00337 ;   rjmp    usbSendAndReti      fallthrough
<a name="l00338"></a>00338 ;---------------------------------------------------------------------------
<a name="l00339"></a>00339 ;usbSend:
<a name="l00340"></a>00340 ;pointer to data in <span class="charliteral">'Y'</span>
<a name="l00341"></a>00341 ;number of bytes in <span class="stringliteral">'cnt'</span> -- including sync byte [range 2 ... 12]
<a name="l00342"></a>00342 ;uses: x1...x4, btcnt, shift, cnt, Y
<a name="l00343"></a>00343 ;Numbers in brackets are time since first bit of sync pattern is sent
<a name="l00344"></a>00344 ;We need not to match the transfer rate exactly because the spec demands 
<a name="l00345"></a>00345 ;only 1.5% precision anyway.
<a name="l00346"></a>00346 usbSendAndReti:               ;- [-13] 13 cycles until SOP
<a name="l00347"></a>00347     in      x2, <a class="code" href="usbdrv_8h.html#3ffc8a49ee40206cfce717574a1ccfea">USBDDR</a>        ;1 [-12]
<a name="l00348"></a>00348     ori     x2, USBMASK       ;1 [-11]
<a name="l00349"></a>00349     sbi     <a class="code" href="usbdrv_8h.html#d95fd90d841998e6b54cb99c49ee1247">USBOUT</a>, USBMINUS  ;2 [-09-10] prepare idle state; D+ and D- must have been 0 (no pullups)
<a name="l00350"></a>00350     in      x1, USBOUT        ;1 [-08] port mirror <span class="keywordflow">for</span> tx loop
<a name="l00351"></a>00351     out     USBDDR, x2        ;1 [-07] &lt;- acquire bus
<a name="l00352"></a>00352   ; need not init x2 (bitstuff history) because sync starts with 0 
<a name="l00353"></a>00353     ldi     x4, USBMASK       ;1 [-06]  exor mask
<a name="l00354"></a>00354     ldi     shift, 0x80       ;1 [-05]  sync byte is first byte sent
<a name="l00355"></a>00355     ldi     bitcnt, 6     ;1 [-04] 
<a name="l00356"></a>00356 txBitLoop:          ;- [-04] [06]
<a name="l00357"></a>00357     sbrs    shift, 0          ;1 [-03] [07]
<a name="l00358"></a>00358     eor     x1, x4            ;1 [-02] [08] 
<a name="l00359"></a>00359     ror     shift             ;1 [-01] [09]  
<a name="l00360"></a>00360 didStuffN:          ;-       [09]
<a name="l00361"></a>00361     out     USBOUT, x1        ;1 [00]  [10] &lt;-- out N
<a name="l00362"></a>00362     ror     x2                ;1 [01]
<a name="l00363"></a>00363     cpi     x2, 0xfc          ;1 [02]
<a name="l00364"></a>00364     brcc    bitstuffN         ;1 [03]
<a name="l00365"></a>00365     dec     bitcnt            ;1 [04]
<a name="l00366"></a>00366     brne    txBitLoop         ;1 [05]
<a name="l00367"></a>00367     sbrs    shift, 0          ;1 [06]
<a name="l00368"></a>00368     eor     x1, x4            ;1 [07]
<a name="l00369"></a>00369     ror     shift             ;1 [08]
<a name="l00370"></a>00370 didStuff6:      ;- [08]
<a name="l00371"></a>00371     nop       ;1 [09]
<a name="l00372"></a>00372     out     USBOUT, x1        ;1 [00] [10] &lt;-- out 6
<a name="l00373"></a>00373     ror     x2                ;1 [01] 
<a name="l00374"></a>00374     cpi     x2, 0xfc          ;1 [02]
<a name="l00375"></a>00375     brcc    bitstuff6         ;1 [03]
<a name="l00376"></a>00376     sbrs    shift, 0          ;1 [04]
<a name="l00377"></a>00377     eor     x1, x4            ;1 [05]
<a name="l00378"></a>00378     ror     shift             ;1 [06]
<a name="l00379"></a>00379     ror     x2                ;1 [07]
<a name="l00380"></a>00380 didStuff7:      ;- [07]
<a name="l00381"></a>00381     ldi     bitcnt, 6     ;1 [08]
<a name="l00382"></a>00382     cpi     x2, 0xfc          ;1 [09]
<a name="l00383"></a>00383     out     USBOUT, x1        ;1 [00] [10] &lt;-- out 7
<a name="l00384"></a>00384     brcc    bitstuff7         ;1 [01]
<a name="l00385"></a>00385     ld      shift, y+         ;2 [02+03]
<a name="l00386"></a>00386     dec     cnt               ;1 [04]
<a name="l00387"></a>00387     brne    txBitLoop       ;1 [05]
<a name="l00388"></a>00388 makeSE0:
<a name="l00389"></a>00389     cbr     x1, USBMASK       ;1 [06]   prepare SE0 [spec says EOP may be 19 to 23 cycles]
<a name="l00390"></a>00390     lds     x2, <a class="code" href="usbdrv_8c.html#b9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a>;2 [07+08]
<a name="l00391"></a>00391     lsl     x2                  ;1 [09] we compare with left shifted address
<a name="l00392"></a>00392 ;2006-03-06: moved transfer of <span class="keyword">new</span> address to <a class="code" href="usbdrv_8c.html#3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a> from C-Code to <span class="keyword">asm</span>:
<a name="l00393"></a>00393 ;<span class="keyword">set</span> address only after data packet was sent, not after handshake
<a name="l00394"></a>00394     out     USBOUT, x1        ;1 [00] [10] &lt;-- out SE0-- from now 2 bits==20 cycl. until bus idle
<a name="l00395"></a>00395     subi    YL, 20 + 2          ;1 [01] Only assign address on data packets, not ACK/NAK in x3
<a name="l00396"></a>00396     sbci    YH, 0             ;1 [02]
<a name="l00397"></a>00397     breq    skipAddrAssign    ;1 [03]
<a name="l00398"></a>00398     sts     <a class="code" href="usbdrv_8c.html#3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a>, x2 ;2 [04+05] <span class="keywordflow">if</span> not skipped: SE0 is one cycle longer
<a name="l00399"></a>00399 ;----------------------------------------------------------------------------
<a name="l00400"></a>00400 ;end of usbDeviceAddress transfer
<a name="l00401"></a>00401 skipAddrAssign:       ;- [03/04]
<a name="l00402"></a>00402     ldi     x2, 1&lt;&lt;<a class="code" href="usbdrv_8h.html#bdde2e43a66667f867e3b9ad89a0a31a">USB_INTR_PENDING_BIT</a> ;1 [05] int0 occurred during TX -- clear pending flag
<a name="l00403"></a>00403     USB_STORE_PENDING(x2)           ;1 [06]
<a name="l00404"></a>00404     ori     x1, <a class="code" href="usbdrv_8h.html#c25f08289ea025246d9682f4ea84ff17">USBIDLE</a>         ;1 [07]
<a name="l00405"></a>00405     in      x2, USBDDR          ;1 [08]
<a name="l00406"></a>00406     cbr     x2, USBMASK         ;1 [09] <span class="keyword">set</span> both pins to input
<a name="l00407"></a>00407     mov     x3, x1              ;1 [10]
<a name="l00408"></a>00408     cbr     x3, USBMASK         ;1 [11] configure no pullup on both pins
<a name="l00409"></a>00409     ldi     x4, 3               ;1 [12]
<a name="l00410"></a>00410 se0Delay:       ;- [12] [15] 
<a name="l00411"></a>00411     dec     x4                  ;1 [13] [16] 
<a name="l00412"></a>00412     brne    se0Delay            ;1 [14] [17] 
<a name="l00413"></a>00413     nop2        ;2      [18+19]
<a name="l00414"></a>00414     out     USBOUT, x1          ;1      [20] &lt;--out J (idle) -- end of SE0 (EOP sig.)
<a name="l00415"></a>00415     out     USBDDR, x2          ;1      [21] &lt;--release bus now
<a name="l00416"></a>00416     out     USBOUT, x3          ;1      [22] &lt;--ensure no pull-up resistors are active
<a name="l00417"></a>00417     rjmp    doReturn      ;1  [23]
<a name="l00418"></a>00418 ;---------------------------------------------------------------------------
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 30 20:43:20 2009 for USB IR HID Device by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
